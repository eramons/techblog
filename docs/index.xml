<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Technical Blog on Small Technical Blog</title>
    <link>https://eramons.github.io/techblog/</link>
    <description>Recent content in Small Technical Blog on Small Technical Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 E. Ramon</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/techblog/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Build Coreboot</title>
      <link>https://eramons.github.io/techblog/post/build_coreboot/</link>
      <pubDate>Mon, 25 Feb 2019 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/build_coreboot/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;DISCLAIMER: try anything described here at your own risk! These are just my notes. That it did work for me then does not mean this would work for you now.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After successfully installing coreboot on my librem 13 v1, I noticed that unfortunately the wifi wasn&amp;rsquo;t working anymore. Since the coreboot version I flashed previously wasn&amp;rsquo;t quite new, I decided to build a new rom image myself using the newest coreboot source code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Replace coreboot with an up-to-date, self-built coreboot version&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Get needed files: source code, purism configuration and binary blobs&lt;/li&gt;
&lt;li&gt;Configure and build coreboot&lt;/li&gt;
&lt;li&gt;Install coreboot&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-get-the-files&#34;&gt;1. Get the files&lt;/h2&gt;

&lt;p&gt;Get coreboot source code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://review.coreboot.org/coreboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install build dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install -y bison build-essential curl flex git gnat libncurses5-dev m4 zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install flashrom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flashrom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build coreboot toolchain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd coreboot
make crossgcc-i386 CPUS=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build cbfstool and ifdtool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd util/cbfstool
make
cd ../util/ifdtool
make
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since coreboot was already on my laptop, I was able to extract the binary blobs from the machine itself.&lt;/p&gt;

&lt;p&gt;I analyzed purism&amp;rsquo;s coreboot installation script (see references below) in order to find out how to get the binary blobs. I wrote a small script myself basing on theirs with a minimal set of commands to get the six necessary blobs. See comments on the scripts for details.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash -e
# extract.sh - Extract binary blobs from librem 13 v1 already running coreboot
set -x

# Librem 13 v1 and Librem 15 v2 binary blob hashes
BDL_UCODE_SHA=&amp;quot;69537c27d152ada7dce9e35bfa16e3cede81a18428d1011bd3c33ecae7afb467&amp;quot;
BDL_DESCRIPTOR_SHA=&amp;quot;be34b19b4de387a07d4fc859d2e4ee44723756f5f54552f236136679b4e52c46&amp;quot;
BDL_MRC_SHA=&amp;quot;dd05ab481e1fe0ce20ade164cf3dbef3c479592801470e6e79faa17624751343&amp;quot;
BDL_REFCODE_SHA=&amp;quot;8a919ffece61ba21664b1028b0ebbfabcd727d90c1ae2f72b48152b8774323a4&amp;quot;
BDL_VBIOS_SHA=&amp;quot;e1cd1b4f2bd21e036145856e2d092eb47c27cdb4b717c3b182a18d8c0b1d0f01&amp;quot;

# CPU Microcode Blob URL (same link as Purism uses)
BDL_UCODE_URL=&amp;quot;https://github.com/platomav/CPUMicrocodes/raw/18a85ffed180447aa16c2796146ff2698691eddf/Intel/cpu306D4_platC0_ver0000002A_2018-01-18_PRD_CC79BBDA.bin&amp;quot;

# Clone the coreboot files from purism&#39;s github:
git clone https://source.puri.sm/coreboot/coreboot-files.git

# Create blob directory, following coreboot file structure
mkdir 3rdparty/blobs/mainboard/purism/librem_bdw

# 0. Get the currently installed coreboot image with flashrom
flashrom -p internal:laptop=force_I_want_a_brick,ich_spi_mode=hwseq -r coreboot-orig.rom

# 1. Use ifdtool to extract the flash regions from the rom image
# Copy me.bin which corresponds to the second flash region
util/ifdtool/ifdtool -x coreboot-orig.rom
cp flashregion_2_intel_me.bin 3rdparty/blobs/mainboard/purism/librem_bdw/me.bin

# 2. Download cpu_microcode_blob.bin and check hash
wget -O 3rdparty/blobs/mainboard/purism/librem_bdw/cpu_microcode_blob.bin $BDL_UCODE_URL
if [ &amp;quot;$(sha256sum 3rdparty/blobs/mainboard/purism/librem_bdw/cpu_microcode_blob.bin | awk &#39;{print $1}&#39;)&amp;quot; != &amp;quot;$BDL_UCODE_SHA&amp;quot; ]; then
        echo &amp;quot;Fatal: wrong hash mrc.bin&amp;quot;
        exit 1
fi

# 3. Extract mrc.bin from the rom image and check hash
util/cbfstool/cbfstool coreboot-orig.rom extract -n mrc.bin -f 3rdparty/blobs/mainboard/purism/librem_bdw/mrc.bin
if [ &amp;quot;$(sha256sum 3rdparty/blobs/mainboard/purism/librem_bdw/mrc.bin | awk &#39;{print $1}&#39;)&amp;quot; != &amp;quot;$BDL_MRC_SHA&amp;quot; ]; then
        echo &amp;quot;Fatal: wrong hash mrc.bin&amp;quot;
        exit 1
fi

# 4. Extract refcode.elf from the rom image and check hash
util/cbfstool/cbfstool coreboot-orig.rom extract -n fallback/refcode -f 3rdparty/blobs/mainboard/purism/librem_bdw/refcode.elf -m x86
if [ &amp;quot;$(sha256sum 3rdparty/blobs/mainboard/purism/librem_bdw/refcode.elf | awk &#39;{print $1}&#39;)&amp;quot; != &amp;quot;$BDL_REFCODE_SHA&amp;quot; ]; then
        echo &amp;quot;Fatal: wrong hash refcode.elf&amp;quot;
        exit 1
fi

# 5. Extract vgabios.bin from the rom image and check hash
util/cbfstool/cbfstool coreboot-orig.rom extract -n pci8086,1616.rom -f 3rdparty/blobs/mainboard/purism/librem_bdw/vgabios.bin
if [ &amp;quot;$(sha256sum 3rdparty/blobs/mainboard/purism/librem_bdw/vgabios.bin | awk &#39;{print $1}&#39;)&amp;quot; != &amp;quot;$BDL_VBIOS_SHA&amp;quot; ]; then
        echo &amp;quot;Fatal: wrong hash vgabios.bin&amp;quot;
        exit 1
fi

# 6. Get descriptor.bin from purism&#39;s repository (coreboot-files) and check hash
 cp coreboot-files/descriptor-bdl.bin 3rdparty/blobs/mainboard/purism/librem_bdw/descriptor.bin
if [ &amp;quot;$(sha256sum 3rdparty/blobs/mainboard/purism/librem_bdw/descriptor.bin | awk &#39;{print $1}&#39;)&amp;quot; != &amp;quot;$BDL_DESCRIPTOR_SHA&amp;quot; ]; then
        echo &amp;quot;Fatal: wrong hash descriptor.bin&amp;quot;
        exit 1
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-configure-and-build-coreboot&#34;&gt;2. Configure and build coreboot&lt;/h2&gt;

&lt;p&gt;Copy the .config file from purism&amp;rsquo;s coreboot-files. Run make menuconfig and save in order to update the configuration including all settings not included in the config.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp coreboot-files/configs/config.librem13v1 .config
make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following file paths must be corrected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-CONFIG_BOOTSPLASH_FILE=&amp;quot;bootsplash.jpg&amp;quot;
+CONFIG_BOOTSPLASH_FILE=&amp;quot;coreboot-files/bootsplash.jpg&amp;quot;

-CONFIG_SEABIOS_BOOTORDER_FILE=&amp;quot;bootorder.txt&amp;quot;
+CONFIG_SEABIOS_BOOTORDER_FILE=&amp;quot;coreboot-files/bootorder-l13v1.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now .config is ready and we can build coreboot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-install-coreboot&#34;&gt;3. Install coreboot&lt;/h2&gt;

&lt;p&gt;Before flashing, reboot including the kernel parameter iomem=relaxed, otherwise flashrom will fail. For this, press &amp;ldquo;e&amp;rdquo; when the grub menu is shown and edit the kernel command line manually.&lt;/p&gt;

&lt;p&gt;After reboot, I flashed the new image I had just built:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo flashrom -p internal:laptop=force_I_want_a_brick -c MX25L6405D -w build/coreboot.rom 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then a cool reboot - luckily the computer still booted :D&lt;/p&gt;

&lt;p&gt;I saw first the SeeBios message, then the Purism Logo and then the Grub boot menu.&lt;/p&gt;

&lt;p&gt;The wifi wasn&amp;rsquo;t working yet. However, that is another story and shall be told another time ;)&lt;/p&gt;

&lt;p&gt;References and sources:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.coreboot.org/lessons/lesson1.html&#34; target=&#34;_blank&#34;&gt;Coreboot Rookie Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://puri.sm/coreboot&#34; target=&#34;_blank&#34;&gt;https://puri.sm/coreboot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.flashrom.org/FAQ&#34; target=&#34;_blank&#34;&gt;Flashrom FAQ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/techblog/post/coreboot_librem&#34; target=&#34;_blank&#34;&gt;Coreboot on Librem&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Install Coreboot on the Librem 13 v.1</title>
      <link>https://eramons.github.io/techblog/post/coreboot_librem/</link>
      <pubDate>Mon, 18 Feb 2019 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/coreboot_librem/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;DISCLAIMER: try this at your own risk! The information below it&amp;rsquo;s just a summary of my notes and experiences during the installation of coreboot on my notebook.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I am the proud owner of a Librem 13 v1 (bought in September 2016). Currently all librem laptops are shipped with coreboot installed on them, but mine was still shipped with propietary firmware on it. Fortunately coreboot is supported anyway - it was possible for me to install coreboot myself.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Replace the propietary bootloader firmware shipped with the Librem 13 v.1 with coreboot&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Switch from an UEFI install to a BIOS one&lt;/li&gt;
&lt;li&gt;Backup the firmware&lt;/li&gt;
&lt;li&gt;Flash coreboot&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-migrate-to-a-non-uefi-installation&#34;&gt;1. Migrate to a non-UEFI installation&lt;/h2&gt;

&lt;p&gt;The librem supports Coreboot with SeaBios as payload. Tianocore is not supported, so an UEFI installation won&amp;rsquo;t boot after replacing the bootloader.&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check if the debian system installed on the laptop is a UEFI or a BIOS install&lt;/li&gt;
&lt;li&gt;Check if the partition layout is MBR or GPT&lt;/li&gt;
&lt;li&gt;Resize the existing partitions in order to free 100 MB at the beginning of the disk&lt;/li&gt;
&lt;li&gt;Create a new 100 MB partition&lt;/li&gt;
&lt;li&gt;Re-install grub&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When I got my librem 13 on September 2016, I replaced the shipped OS (PureOS) through an UEFI-booted debian system. In order to make sure the OS is indeed installed on UEFI mode, I quickly checked:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There is a /sys/firmware/efi on the rootfs&lt;/li&gt;
&lt;li&gt;There is a fat32 partition (called &amp;ldquo;efi&amp;rdquo;) mounted on /boot/efi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two possible partition schemes exist:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MBR (Master Boot Record): older&lt;/li&gt;
&lt;li&gt;GPT (GUID Partition Table): newer - required to boot operating systems in UEFI mode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s important to know which one is being used. Since the OS installation was an UEFI-mode debian, it was for sure that the disk scheme had to be GPT.&lt;/p&gt;

&lt;p&gt;Anyway, it&amp;rsquo;s possible to check this for example looking at the output of fdisk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sda
	...
Disklabel type: gpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or even better gdisk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gdisk /dev/sda
	...
Partition table scan:
	MBR: protective
	BSD: not present
	APM: not present
	GPT: present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use grub as 2nd stage bootloader. In non-EFI mode, grub is able to boot from a partitioned GPT disk if using a compatible boot scheme, which consists on having a special 100 MB partition at the start of the disk.&lt;/p&gt;

&lt;p&gt;I looked at the partitions on my librem (you can use either gparted or gdisk):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;/dev/sda1 - boot:  ext4 partition mounted on /boot with size=500 MB (113 MB used)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/dev/sda2 - efi: fat32 partition mounted on /boot/efi with size=500 MB and flags &amp;ldquo;boot&amp;rdquo; and &amp;ldquo;esp&amp;rdquo; set&lt;/li&gt;
&lt;li&gt;/dev/sda3 - system: crypt-luks (encrypted) partition&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The boot partition must be resized and moved in order to have a new 100 MB partition at the beginning of the disk. Since the partitions must be unmounted to do that, I created a live debian stretch usb drive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=/home/eramon/Downloads/debian-live-9.8.0-amd64-gnome.iso of=/dev/sdb bs=1M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Reboot to the live system on the usb.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Boot from the USB drive (pressing F2 to enter setup and selecting boot override).&lt;/p&gt;

&lt;p&gt;On the live CD, I used gparted to resize the boot partition, freing 100 MB at the beginning of the disk.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gparted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Reboot to the debian system.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I used gdisk to create the new 100 MB partition for grub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Command (? for help): n
Partition number (4-128, default 4):
First sector (34-976773134, default = 2048) or {+-}size{KMGTP}:
Last sector (2048-206847, default = 206847) or {+-}size{KMGTP}: +100M
Current type is &#39;Linux filesystem&#39;
Hex code or GUID (L to show codes, Enter = 8300): ef02
Changed type of partition to &#39;BIOS boot partition&#39;

Command (? for help): p 
	...
Number  Start (sector)    End (sector)  Size       Code  Name
   1          206848         1023999   399.0 MiB   8300  boot
   2         1024000         2047999   500.0 MiB   EF00  efi
   3         2048000       976771071   464.8 GiB   8300
   4            2048          206847   100.0 MiB   EF02  BIOS boot partition

Command (? for help): wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify /etc/fstab and comment out the mount of the /boot/efi partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Removed on 2019 February 18th to switch to a non-EFI system to be able to install coreboot:
# UUID=559D-9E15  /boot/efi       vfat    umask=0077      0       1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, I removed grub-efi and installed grub2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg --purge grub-efi
sudo apt-get -f autoremove
sudo apt-get update
sudo apt-get grub2
sudo grub install --target=i386-pc /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The target parameter must be specified, otherwise grub tries to install grub on efi mode.&lt;/li&gt;
&lt;li&gt;Grub must be installed to the disk (/dev/sda) an not to the partition (/dev/sda2 - e.g. the boot partition) as it would be for grub-efi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reboot to see if it worked. To be sure, I went into the bios and tried a boot override. There were two different boot options, both for the same disk. One of them is the UEFI boot and the other is the non-UEFI one. Both worked.&lt;/p&gt;

&lt;h2 id=&#34;2-backup-the-existing-firmware&#34;&gt;2. Backup the existing firmware&lt;/h2&gt;

&lt;p&gt;First install flashrom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flashrom 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flashrom dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install libftdi1 libftdi1-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: the dependencies are installed by the flashrom package. However I used first another flashrom binary, so I had to install the dependencies manually, that&amp;rsquo;s why I&amp;rsquo;m mentioning them here.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Use flashrom to make a backup of the exiting firmware:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flashrom
sudo flashrom -p internal:laptop=force_I_want_a_brick,ich_spi_mode=hwseq -r libremfw_orig.rom  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-install-coreboot&#34;&gt;3. Install Coreboot&lt;/h2&gt;

&lt;p&gt;Purism provides on their website instructions and one script to configure, build and install coreboot on the librem with flashrom (see references). Although I found the information on the site useful, the script didn&amp;rsquo;t work for me. The problem seemed to be that the script needs some binary blobs which should be extracted from the laptop itself, unfortunately this only works if coreboot is already installed on the machine.&lt;/p&gt;

&lt;p&gt;I wrote the purism support, who kindly informed me that the available script was not mantained anymore and who provided me with an image file containing both all necessary binary blobs and coreboot built with the configuration needed by my board:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file coreboot-l13v1.rom 
coreboot-l13v1.rom: Intel serial flash for PCH ROM

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to avoid getting an error during flashing and following the instructions of the flashrom FAQ, I overrided the kernel command line to include iomem=relaxed. In order to do that, press &amp;ldquo;e&amp;rdquo; when the grub menu appears during boot and modify the cmdline manually. Resume boot with F10.&lt;/p&gt;

&lt;p&gt;This is the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enabling flash write... Error accessing ICH RCRB, 0x4000 bytes at 0x00000000fed1c000
/dev/mem mmap failed: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After having booted with a relaxed iomem, I was ready to flash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo flashrom -p internal:laptop=force_I_want_a_brick -w coreboot-l12v1.rom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done :) I rebooted and was greeted by the Purism logo and SeeBios.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: The &amp;ldquo;want a brick&amp;rdquo; option seemed pretty scary to me. Apparently flashrom says the board is not officially supported and enforces the use of this flag to proceed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I include here the flashrom output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/coreboot-l13v1-oem$ sudo ./flashrom -p internal:laptop=force_I_want_a_brick -w coreboot-l13v1.rom
flashrom v1.0 on Linux 4.19.0-2-amd64 (x86_64)
flashrom is free software, get the source code at https://flashrom.org

Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns).
========================================================================
WARNING! You seem to be running flashrom on an unsupported laptop.
Laptops, notebooks and netbooks are difficult to support and we
recommend to use the vendor flashing utility. The embedded controller
(EC) in these machines often interacts badly with flashing.
See the manpage and https://flashrom.org/Laptops for details.

If flash is shared with the EC, erase is guaranteed to brick your laptop
and write may brick your laptop.
Read and probe may irritate your EC and cause fan failure, backlight
failure and sudden poweroff.
You have been warned.
========================================================================
Proceeding anyway because user forced us to.
Found chipset &amp;quot;Intel Broadwell U Premium&amp;quot;.
This chipset is marked as untested. If you are using an up-to-date version
of flashrom *and* were (not) able to successfully update your firmware with it,
then please email a report to flashrom@flashrom.org including a verbose (-V) log.
Thank you!
Enabling flash write... Warning: SPI Configuration Lockdown activated.
Enabling hardware sequencing because some important opcode is locked.
OK.
Found Programmer flash chip &amp;quot;Opaque flash chip&amp;quot; (8192 kB, Programmer-specific) mapped at physical address 0x0000000000000000.
Reading old flash chip contents... done.
Erasing and writing flash chip... Erase/write done.
Verifying flash... VERIFIED.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;References and useful or interesting links:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://puri.sm&#34; target=&#34;_blank&#34;&gt;Purism&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#GUID_Partition_Table_.28GPT.29_specific_instructions&#34; target=&#34;_blank&#34;&gt;ArchLinux Grub Documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://puri.sm/coreboot&#34; target=&#34;_blank&#34;&gt;https://puri.sm/coreboot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.debian.org/CD/live&#34; target=&#34;_blank&#34;&gt;https://www.debian.org/CD/live&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.flashrom.org/FAQ&#34; target=&#34;_blank&#34;&gt;Flashrom FAQ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian on Asus Chromebook Flip C101PA</title>
      <link>https://eramons.github.io/techblog/post/asuschromebook_debian/</link>
      <pubDate>Tue, 04 Dec 2018 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/asuschromebook_debian/</guid>
      <description>

&lt;p&gt;&lt;em&gt;The Asus Chromebook Flip C101PA (bob) is a convertible touchscreen laptop powered by an ARMv8 Rockchip RK3399 hexa-core processor and 4GB RAM, measuring 10.4&amp;rdquo; x 7.2&amp;rdquo; x 0.6&amp;rdquo; and weighing 1 kg.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rockchip RK3399 (OP1) dual-core 2.0GHz Cortex-A72 and quad-core 1.4GHz Cortex-A53 processor&lt;/li&gt;
&lt;li&gt;4GB LPDDR3 RAM&lt;/li&gt;
&lt;li&gt;10.1&amp;rdquo; 1280x800 LED display&lt;/li&gt;
&lt;li&gt;Mali T860MP4 GPU&lt;/li&gt;
&lt;li&gt;16GB eMMC&lt;/li&gt;
&lt;li&gt;38 Whrs battery&lt;/li&gt;
&lt;li&gt;2x USB 3.1 Type-C ports&lt;/li&gt;
&lt;li&gt;1x USB 2.0 Type-A port&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARM Chromebooks ship with the Coreboot bootloader and use Depthcharge as the payload. Further reading:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.coreboot.org&#34; target=&#34;_blank&#34;&gt;Coreboot Website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coreboot/depthcharge&#34; target=&#34;_blank&#34;&gt;Depthcharge Source Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The kernel is signed and packed in a custom format and must be flashed to a dedicated partition on the sdcard or to the internal ssd. Further reading:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.chromium.org/chromium-os/chromiumos-design-docs/disk-format&#34; target=&#34;_blank&#34;&gt;Chromium: Disk Format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;After enabling Developer Mode and USB Boot, it&amp;rsquo;s possible to boot either ChromeOS from the internal disk of the chromebook (Ctrl-D) or from USB (Ctrl-U).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goal: run Debian on the ChromeOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Motivation:&lt;/strong&gt; the Asus C101PA is a light (and cheap) laptop - perfect to carry it everywhere. Using ChromeOS only was not an option for me, so I aimed to run Debian Linux on it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Milestones:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Dual boot ChromeOS and Linux: run archlinux on a sdcard&lt;/li&gt;
&lt;li&gt;Replace the archlinux filesystem with a Debian rootfs&lt;/li&gt;
&lt;li&gt;Replace the kernel (ChromeOS) with the mainline Linux kernel&lt;/li&gt;
&lt;li&gt;Troubleshooting: modify kernel options and install firmware&lt;/li&gt;
&lt;li&gt;Flash the working kernel to the chromebook internal memory&lt;/li&gt;
&lt;li&gt;Replace the kernel (Linux) with the latest Debian kernel&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Files and scripts available in github:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/chromebook&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-archlinux&#34;&gt;1. Archlinux&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: try out a working linux distribution on the Chromebook&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;On the chromebook&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I started taking a look at the excelent Arch Linux wiki:
&lt;a href=&#34;https://archlinuxarm.org/platforms/armv8/rockchip/asus-chromebook-flip-c101pa&#34; target=&#34;_blank&#34;&gt;ArchLinuxArm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This links provides instructions for the installation of Arch Linux from a sdcard in dual boot setup. I closely followed the instructions in order to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Enable Developer Mode&lt;/li&gt;
&lt;li&gt;Enable booting from USB&lt;/li&gt;
&lt;li&gt;Partition the sdcard&lt;/li&gt;
&lt;li&gt;Download the tarball. The Arch Linux tarball includes the ChromeOS kernel and an Arch Linux filesystem.&lt;/li&gt;
&lt;li&gt;Copy the file system to the second partition on the card&lt;/li&gt;
&lt;li&gt;Flash the kernel into the first partition on the card&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-debian-root-file-system&#34;&gt;2. Debian Root File System&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: running Debian system on the sdcard booting the ChromeOS kernel provided by archlinux and a debian filesystem.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the preparation of the debian rootfs, I inserted the sdcard in my laptop and mounted the partition which would host the rootfs. I used then debootstrap to install the base system.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;On the laptop&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Mount the second sdcard partition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir rootfs
sudo mount /dev/sdb2 rootfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use debootstrap in order to create a Debian sid root file system:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo debootstrap --arch=arm64 --verbose --foreign sid rootfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Changeroot to the new created filesystem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo chroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a user and set the user&amp;rsquo;s and the root passwords:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;passwd
adduser eramon
passwd eramon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install wicd-curses openssh-server sudo git xserver-xorg gnome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exit the chroot, umount the filesystem and sync:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;exit
umount rootfs
sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Back on the chromebook&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Insert the sdcard on the chromebook and press CTRL-U as soon as the boot screen appears.&lt;/p&gt;

&lt;p&gt;The firmware files and the modules will be missing on the system. Get them from the archlinux tarball:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo cp -r rootfs/lib/firmware /lib/
sudo cp -r rootfs/lib/modules/* /lib/modules/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module files in archlinux seem to be compressed: they have the extension .ko.gz. In order for them to work with the debian filesystem, I had to unzip them first.&lt;/p&gt;

&lt;h2 id=&#34;3-mainline-linux-kernel&#34;&gt;3. Mainline Linux Kernel&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: replace the ChromeOS kernel through the mainline linux kernel.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As a reference, I read the instructions for building a package on the archlinux PKGBUILD file for linux-gru in order to figure out which steps needed to be done:
&lt;a href=&#34;https://github.com/archlinuxarm/PKGBUILDs/blob/master/core/linux-gru/PKGBUILD&#34; target=&#34;_blank&#34;&gt;archlinuxarm/PKGBUILDS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In order to avoid cross compiling issues and to keep things simple, I aimed to do all the compiling and even the flashing directly on the chromebook. At this stage I had already a working environment consisting on the chromeos kernel and the new debian filesystem.&lt;/p&gt;

&lt;p&gt;First get the mainline kernel source code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git linux-git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get into the source directory and generate a default configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd linux-git
make defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile the kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make Image Dtbs Modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download the kernel.its file used by arch linux to build their package:
&lt;a href=&#34;https://github.com/archlinuxarm/PKGBUILDs/blob/master/core/linux-gru/kernel.its&#34; target=&#34;_blank&#34;&gt;kernel.its&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are several configurations in this file, we only need the first one. We also need to modify the path and name of the dtbs file.&lt;/p&gt;

&lt;p&gt;I modified the file as follows:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/chromebook/mainlinekernel.its&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook/mainlinekernel.its&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dts-v1/;

/ {
    description = &amp;quot;Linux mainline kernel image with one blob&amp;quot;;
    images {
        kernel@1{
            description = &amp;quot;kernel&amp;quot;;
            data = /incbin/(&amp;quot;linux-git/arch/arm64/boot/Image&amp;quot;);
            type = &amp;quot;kernel_noload&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            os = &amp;quot;linux&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            load = &amp;lt;0&amp;gt;;
            entry = &amp;lt;0&amp;gt;;
        };
        fdt@1{
            description = &amp;quot;rk3399-gru-bob.dtb&amp;quot;;
            data = /incbin/(&amp;quot;linux-git/arch/arm64/boot/dts/rockchip/rk3399-gru-bob.dtb&amp;quot;);
            type = &amp;quot;flat_dt&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            hash@1{
                algo = &amp;quot;sha1&amp;quot;;
            };
        };
    };
    configurations {
        default = &amp;quot;conf@1&amp;quot;;
        conf@1{
            kernel = &amp;quot;kernel@1&amp;quot;;
            fdt = &amp;quot;fdt@1&amp;quot;;
        };
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkimage -D &amp;quot;-I dts -O dtb -p 2048&amp;quot; -f mainlinekernel.its vmlinux.uimg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare the cmdline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;console=ttyS2,115200n8 earlyprintk=ttyS2,115200n8 console=tty1 init=/sbin/init root=PARTUUID=%U/PARTNROFF=1 rootwait rw noinitrd loglevel=4&amp;quot; &amp;gt; cmdline_mainline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate an empty bootloader.bin file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=bootloader.bin bs=512 count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run vbutil in order to generate a boot image for the chromebook:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vbutil_kernel
        --pack vmlinux.kpart
        --version 1
        --vmlinuz vmlinux.uimg
        --arch aarch64
        --keyblock /usr/share/vboot/devkeys/kernel.keyblock
        --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk
        --config cmdline_mainline
        --bootloader bootloader.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flash the new generated image to the first partition of the sdcard, sync and reboot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dd if=vmlinuz.kpart of=/dev/mmcblk1p1
sudo sync
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My script automating the aforementioned steps (mkimage, cmdline, vbutil) is available here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/chromebook/blob/master/run.sh&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook/blob/master/run.sh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In case the screen remains blank when trying to boot the new kernel it helps to do serial port debugging with the help of a SuzyQable:
&lt;a href=&#34;https://www.chromium.org/chromium-os/ccd#TOC-SuzyQ-SuzyQable&#34; target=&#34;_blank&#34;&gt;SuzyQable&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use the USB-C port close to the screen, since the other one does not offer a serial port connection.&lt;/li&gt;
&lt;li&gt;Make sure the cable is plugged in the right position (the letters DBG have to be upside).&lt;/li&gt;
&lt;li&gt;Use minicom to connect via serial port and follow the boot process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-troubleshooting&#34;&gt;4. Troubleshooting&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: modify the kernel configuration as needed in order to have all hardware working. Install missing firmware.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After a first test run - compiling and flashing the kernel with the default configuration - I identified several flaws:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The wireless was not working&lt;/li&gt;
&lt;li&gt;The touchscreen was not working&lt;/li&gt;
&lt;li&gt;The touchpad was not working&lt;/li&gt;
&lt;li&gt;The sound was not working&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wireless&#34;&gt;Wireless&lt;/h3&gt;

&lt;p&gt;A look to dmesg revealed that the problem was just that the firmware files were missing.&lt;/p&gt;

&lt;p&gt;Comparing with the running ChromeOS system on the same chromebook, I found out which firmware files were missing and which debian package will provide them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install firmware-libertas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Notes:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;In order to install this firmware the contrib non-free sources must be included in /etc/apt/sources.list&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Before getting the wi-fi to work, I used an ethernet cable and an usb-to-ethernet adapter&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After installing the firmware package wireless networking worked perfectly.&lt;/p&gt;

&lt;h3 id=&#34;touchscreen-touchpad&#34;&gt;Touchscreen &amp;amp; Touchpad&lt;/h3&gt;

&lt;p&gt;In order for the touchscreen and the touchpad to work, we need to manually add the missing kernel modules to the kernel configuration and re-compile.&lt;/p&gt;

&lt;p&gt;Edit .config to include the following devices as kernel modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CONFIG_MOUSE_ELAN_I2C=m
CONFIG_MOUSE_ELAN_I2C_I2C=m
CONFIG_TOUCHSCREEN_ELAN=m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-build the kernel with make, make a new version with mkimage and generate a chromebook bootable image with vbutil_kernel, same as before.&lt;/p&gt;

&lt;p&gt;After this, we see the elan touchpad in /proc/bus/input/devices. The touchpad is working.&lt;/p&gt;

&lt;h3 id=&#34;sound&#34;&gt;Sound&lt;/h3&gt;

&lt;p&gt;The sound wasn&amp;rsquo;t working, although the corresponding modules seemed to be in place after comparing with a running ChromeOS system on the same device.&lt;/p&gt;

&lt;p&gt;In addition, the sound settings in gnome only showed a &amp;ldquo;dummy output&amp;rdquo; as sound device. Apparently Debian does not include users in the audio group by default, so adding the user to the group improved the situation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adduser eramon audio 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the sound wasn&amp;rsquo;t still working, I was able to see two proper output devices in the sound settings in gnome.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;At the time of this writing, the sound is still not working.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;further-issues&#34;&gt;Further issues&lt;/h3&gt;

&lt;p&gt;There is some other issues I did not go into:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The system seems to recover well from suspend when it suspends in its own (after no pressing any key for a while). However, if closing the lid manually, the system is not able to recover.&lt;/li&gt;
&lt;li&gt;The sound, brightness and other such keys (the top row on the Asus Chromebook keyboard) does not work as intended. Maybe just a configuration issue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-kernel-and-rootfs-on-the-chromebook-disk&#34;&gt;5. Kernel and rootfs on the chromebook disk&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: Instead of booting from the sdcard, boot from the chromebook internal ssd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we&amp;rsquo;ll need several tries in order for the custom built kernel to boot, it&amp;rsquo;s good to be able to boot both from the sdcard and from the internal drive. With Ctrl-D we&amp;rsquo;ll be able to boot the experimental kernel we are building and with Ctrl-U we&amp;rsquo;ll always be able to boot the already working mainline kernel on the sdcard first partition.&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use gparted to resize the stateful partition&lt;/li&gt;
&lt;li&gt;Create a new KERN-D and ROOT-D partitions and change the boot priorities&lt;/li&gt;
&lt;li&gt;Flash the kernel to the KERN-D partition&lt;/li&gt;
&lt;li&gt;Install a base debian system on ROOT-D using debootstrap&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Consequence: ChromeOS won&amp;rsquo;t boot anymore. The reason is that resizing a partition changes the boot priority of the KERN partitions on the same disk as the resized partition.&lt;/p&gt;

&lt;p&gt;If you plan to restore ChromeOS at some point, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cgpt show /dev/mmcblk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the output. In order to have ChromeOS to boot again, the values of this fields must be set as they were originally (using cgpt).
For example, the following command will restore the settings of KERN-A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cgpt add -i 2 -S 1 -T 0 -P 2 /dev/mmcblk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that after doing this, it won&amp;rsquo;t be possible to boot debian anymore with Ctrl-D. Unfortunately coreboot/depthcharge only allow to boot one kernel (with Ctrl-D).&lt;/p&gt;

&lt;p&gt;Original settings (output of cgpt show):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;KERN-A: priority=2 tries=0 successful=1&lt;/li&gt;
&lt;li&gt;KERN-B: priority=1 tries=0 successful=1&lt;/li&gt;
&lt;li&gt;KERN-C: priority=0 tries=15 successful=0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So I resized the so called &amp;ldquo;stateful partition&amp;rdquo; from 10.53 GB to 5.00 GB:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     8671232    10485760       1  Label: &amp;quot;STATE&amp;quot;
                                  Type: Linux data
                                  UUID: 1F4D5818-8E6B-0746-B1F9-E2E206777C85
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I created two new partitions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For my debian kernel: KERN-D with size 100 MB&lt;/li&gt;
&lt;li&gt;For my debian rootfs: ROOT-D with size 9.45 GB (e.g. all unallocated space after resize STATE and creating KERN-D)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    30539776      204800      13  Label: &amp;quot;KERN-D&amp;quot;
                                  Type: ChromeOS kernel
                                  UUID: 9CAA153C-8A88-0A4D-B750-FA2F52FB3A2E
                                  Attr: priority=10 tries=5 successful=1 
    10719232    19820544      14  Label: &amp;quot;ROOT-D&amp;quot;
                                  Type: 0FC63DAF-8483-4772-8E79-3D69D8477DE4
                                  UUID: C5E4E377-6D8F-4747-AA1F-6A8EEDDF031A
                                  UUID: C5E4E377-6D8F-4747-AA1F-6A8EEDDF031A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set the priority, tries and succesful flag for the KERN-D partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cgpt add -i 1 -S 1 -T 0 -P 2 /dev/mmcblk0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use debootstrap to create a debian rootfs on the new ROOT-D:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/mmcblk1p14 dev/mnt
sudo debootstrap sid dev/mnt
sudo chroot dev/mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After chroot-ing to the new filesystem, I set the hostname, the root password, created an user and installed some useful packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;passwd
adduser eramon
cat &amp;quot;chupito&amp;quot; &amp;gt; /etc/hostname
apt-get install locales wicd-curses sudo
dpkg-reconfigure locales
visudo
exit
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test the new setup is working, I flashed the working mainline kernel to KERN-D. For that, I modified the cmdline in order to use ROOT-D as the rootfs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;quot;console=ttyS2,115200n8 earlyprintk=ttyS2,115200n8 console=tty0 init=/sbin/init root=PARTUUID=c5e4e377-6d8f-4747-aa1f-6a8eeddf031a rootwait rw noinitrd loglevel=4&amp;quot; &amp;gt; cmdline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: the PARTUUID of the rootfs partition is hardcoded - it shouldn&amp;rsquo;t but I did not know how to do otherwise&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To find out the PARTUUID of ROOT-D:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l /dev/disk/by-partuuid/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run vbutil as before using this modified cmdline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vbutil_kernel 
	--pack vmlinux.kpart 
	--version 1 
	--vmlinuz vmlinux.uimg 
	--arch aarch64 
	--keyblock /usr/share/vboot/devkeys/kernel.keyblock 
	--signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk 
	--config cmdline 
	--bootloader bootloader.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flash the modified kernel image to the KERN-D partition and reboot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=vmlinux.kpart of=/dev/mmcblk1p13
sudo sync
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After doing this, I was able to boot my custom mainline kernel with Ctrl-D. Once logged in over serial, we can install the X system and other necessary packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install xserver-xorg gnome firmware-libertas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE I: same as before and before getting the wi-fi to work, I had to use a network cable.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE II: the chromebook has only a little drive (16 GB). For a productive setup, I ended up moving my /home partition to the sdcard - letting only the base system / on the ROOT-D partition.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-debian-kernel&#34;&gt;6. Debian Kernel&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: replace the mainline linux kernel through the latest debian kernel.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get the latest kernel source&lt;/li&gt;
&lt;li&gt;Modify the kernel in order to include the modules for the touchpad and touchscreen to work&lt;/li&gt;
&lt;li&gt;Build the debian package and install it&lt;/li&gt;
&lt;li&gt;Modify the FDT image in order to include an initramfs since the debian kernel can&amp;rsquo;t boot without it&lt;/li&gt;
&lt;li&gt;Build the kernel image&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Instructions for re-building a debian kernel package (see &amp;ldquo;Building a custom kernel from Debian kernel source&amp;rdquo;):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kernel-team.pages.debian.net/kernel-handbook/ch-common-tasks.html#s-common-official&#34; target=&#34;_blank&#34;&gt;Rebuilding official Debian kernel packages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Get the kernel source code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install linux-source-4.19
tar xaf /usr/src/linux-source-4.19.16.tar.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install build-essential, fakeroot, build-dep, devscripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the following command in order to generate the default configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit .config in order to include the necessary kernel modules we found out in the &amp;ldquo;Troubleshooting&amp;rdquo; section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi .config

CONFIG_MOUSE_PS2_ELANTECH=m
CONFIG_MOUSE_ELAN_I2C=m
CONFIG_TOUCHSCREEN_ELAN=m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;TODO: In order for the device to be supported in the future, submit a bug to the debian kernel team in order to suggest including the missing modules.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Build the kernel package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make deb-pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install following file - generated by a succesfull build:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -i linux-image-4.19.16-1_arm64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install -among others- the following files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/boot/initrd-img-4.19.16
/boot/dtbs/rockchip/rk3399-gru-bob.dtb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chromebooks don&amp;rsquo;t use a ramdisk for booting. For the mainline kernel we used before, we didn&amp;rsquo;t use one either. However in order for Debian to boot, a initramfs (or ramdisk) is mandatory.&lt;/p&gt;

&lt;p&gt;Get the files we need for making the image and which will be referenced in kernel.its:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kernel: get the Image file from the compiled source: arch/arm64/boot/Image&lt;/li&gt;
&lt;li&gt;ramdisk: /boot/initrd-img-4.19.16 installed by dpkg before&lt;/li&gt;
&lt;li&gt;dtb: arch/arm64/boot/dts/rockchip/rk3399-gru-bob.dtb (also available under /boot/dtbs/rockchip/rk3399-gru-bob.dtb installed by dpkg before)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Edit the kernel.its file we used before in order to include a ramdisk:
&lt;a href=&#34;https://github.com/eramons/chromebook/blob/master/debkernel.its&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook/blob/master/debkernel.its&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dts-v1/;

/ {
    description = &amp;quot;Debian kernel image with one blob for the Asus C101 (Bob) and initramfs&amp;quot;;

    images {
        kernel@1{
            description = &amp;quot;kernel&amp;quot;;
            data = /incbin/(&amp;quot;linux/debian/arch/arm64/boot/Image&amp;quot;);
            type = &amp;quot;kernel_noload&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            os = &amp;quot;linux&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            load = &amp;lt;0&amp;gt;;
            entry = &amp;lt;0&amp;gt;;
        };
        fdt@1{
            description = &amp;quot;rk3399-gru-bob.dtb&amp;quot;;
            data = /incbin/(&amp;quot;linux/debian/arch/arm64/boot/dts/rockchip/rk3399-gru-bob.dtb&amp;quot;);
            type = &amp;quot;flat_dt&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            hash@1{
                algo = &amp;quot;sha1&amp;quot;;
            };
        };
	ramdisk@1 {
           description = &amp;quot;initramfs&amp;quot;;
           data = /incbin/(&amp;quot;/boot/initrd.img-4.19.16&amp;quot;);
           type = &amp;quot;ramdisk&amp;quot;;
           arch = &amp;quot;arm64&amp;quot;;
           compression = &amp;quot;none&amp;quot;;
           hash@1 {
                algo = &amp;quot;sha1&amp;quot;;
           };
	};
    };
    configurations {
        default = &amp;quot;conf@1&amp;quot;;
        conf@1{
            kernel = &amp;quot;kernel@1&amp;quot;;
            fdt = &amp;quot;fdt@1&amp;quot;;
            ramdisk = &amp;quot;ramdisk@1&amp;quot;;
        };
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkimage -D &amp;quot;-I dts -O dtb -p 2048&amp;quot; -f debkernel.its vmlinux.uimg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find out the partition UID of the root partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l /dev/disk/by-partuuid/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare the cmdline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;console=ttyS2,115200n8 earlyprintk=ttyS2,115200n8 console=tty0 init=/sbin/init root=PARTUUID=c5e4e377-6d8f-4747-aa1f-6a8eeddf031a rootwait rw loglevel=4&amp;quot; &amp;gt; cmdline_debian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate an empty bootloader.bin file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=bootloader.bin bs=512 count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run vbutil in order to generate a boot image for the chromebook:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vbutil_kernel 
	--pack vmlinux.kpart 
	--version 1 
	--vmlinuz vmlinux.uimg 
	--arch aarch64 
	--keyblock /usr/share/vboot/devkeys/kernel.keyblock 
	--signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk 
	--config cmdline_debian 
	--bootloader bootloader.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flash the new generated image to the ROOT-D partition on the chromebook, sync and reboot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dd if=vmlinuz.kpart of=/dev/mmcblk1p14
sudo sync
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done :) Debian on the chromebook: a debian rootfs and a customized, self-built debian kernel.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And now? Next steps:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Coreboot/Depthcharge: build an u-boot payload for the Asus C101. Extend flash-kernel to support the board.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Alternatively, build a second depthcharge payload loaded through the legacy mechanism provided by the chromebooks (Ctrl-L) which loads the KERN-D kernel.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Debian on Radxa Rock Square</title>
      <link>https://eramons.github.io/techblog/post/rock2_debian/</link>
      <pubDate>Thu, 27 Jul 2017 15:03:58 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/rock2_debian/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Radxa Rock 2 Square is a Rockchip RK3288 based solution.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.radxa.com/rock2/images/e&#34; target=&#34;_blank&#34;&gt;Available images&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The available images run with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A modified version of u-boot&lt;/li&gt;
&lt;li&gt;The Rabian operating system (which is based on Debian 8)&lt;/li&gt;
&lt;li&gt;A custom radxa kernel.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The goal is to get a pure Debian distribution up and running on the board:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Debian u-boot&lt;/li&gt;
&lt;li&gt;Debian armhf linux-image kernel&lt;/li&gt;
&lt;li&gt;Pure Debian root file system&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For this small project, we have two Radxa Rock 2 Square boards:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first one used for development, on which we aim to run Debian, booting the Radxa kernel with the Radxa u-boot. We&amp;rsquo;ll run using the internal flash storage of the board. This will be the &lt;em&gt;Development Board&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The second one used as testing platform. The goal is to be able to boot an official Debian kernel on this one using the official Debian u-boot and run an unmodified Debian sid on it. We&amp;rsquo;ll boot from a SD card. This will be the &lt;em&gt;Integration Board&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We also need a SD card with a capacity of 8 gigabytes at least.&lt;/p&gt;

&lt;h2 id=&#34;try-out-a-debian-based-distribution&#34;&gt;Try out a debian-based distribution&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Connect the board to a keyboard and a monitor or use the serial port of the board and minicom from your laptop to see the output of the board.&lt;/p&gt;

&lt;p&gt;First of all, we will try an existing image to see how it works. The image we are using is a Debian-based one which will be flashed to the board internal storage. Flashing an existing image to the board with the instructions and flash tool provided by Radxa is straightforward, just follow the instructions on the website:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.radxa.com/Rock/flash_the_image&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Flash the image&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In a nutshell:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Download the Image:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.radxa.com/rock2/images/rabian/emmc/rock2_square_rabian_150720_5d53487_emmc.img.xz&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Rabian SD Image&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Download and unzip the Radxa flashing tool:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.radxa.com/rock/tools/linux/Linux_Upgrade_Tool_v1.21.zip&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Radxa Flashing Tool&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Boot the board in bootloader mode and flash the image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo radxa/Linux_Upgrade_Tool_v1.21/upgrade_tool uf radxa/rock2_square_rabian_150720_5d53487_emmc.img
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A better alternative is to use the rkflashtool which is available as a Debian package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install rkflashtool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The board will reboot automatically after the image flash is completed. Attaching a HDMI monitor and a keyboard to the board you should be able to log in to the Rabian system. Both the username and the password are &amp;ldquo;rock2&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;create-debian-rootfs&#34;&gt;Create Debian rootfs&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;After having tried out Rabian on the Rock2, we aim to run a newer, unmodified version of Debian on the board. In order to go there, we need to replace the root filesystem through a self-built one.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use the Debian utility debootstrap for building the rootfs. The easiest and safest way is to use the available Rabian system - before replacing the rootfs - for setting up a custom rootfs with debootstrap.&lt;/p&gt;

&lt;p&gt;NOTE: it is also possible to generate the rootfs on other platform, using debootstrap &amp;ndash;first-stage on the host architecture and &amp;ndash;second-state using qemu. However, trying to do so lead to an EXT3 journal during the booting process. The reason is that the mkfs version used for creating the file system was much newer than the radxa kernel, which at the time of this writting was already quite old.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Boot the board and log in to the system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;username: rock2
password:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create the file which will host the root file system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=debian.ext4 bs=1M count=4096
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create an ext4 filesystem on the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkfs.ext4 debian.ext4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The execution of the mkfs command is actually the reason for creating the rootfs file on the Rock2 directly. Creating the file system on another host which a newer kernel can lead to a journal error when trying to boot the system afterwards.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mount the file as a loop device:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount -o loop rootfs.ext4 /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use Debootstrap to download a Debian sid to the mount point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;debootstrap sid /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the kernel modules from the running Rabian system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /mnt/lib/modules
sudo cp -r /lib/modules/* /mnt/lib/modules

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change root to the new filesystem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chroot /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using sudo, allow root rights to the new created user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;visudo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add root mount point to fstab:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo echo &amp;quot;/dev/mmcblk0p2 / ext4 relatime,errors=remount-ro 0 1&amp;quot; &amp;gt; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do some fine tuning on the new filesystem.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Create a non-root user (and set his password):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adduser eramon
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install some packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install sudo, openssh-server, locales
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course further installation of packages can follow later after we finally boot the system.j&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modify /etc/network/interfaces in order for the new system to get connectivity automatically&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set the hostname:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo absinthe &amp;gt; /etc/hostname
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add the following line to  /etc/hosts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.0.1   absinthe
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The Debian filesystem is now ready. Umount the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo umount /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the file to your laptop or computer. We&amp;rsquo;ll use it twice afterwards:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Flash the filesystem on the development board&lt;/li&gt;
&lt;li&gt;Copy the rootfs to the second partition of the sdcard&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;flash-the-filesystem&#34;&gt;Flash the filesystem&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The default rootfs (Rabian) provided with the complete image we flashed at the beginning will be now replaced by our own Debian rootfs. In order to do that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Put the board into bootloader mode (same as you did before when flashing the complete image)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the radxa flashtool for flashing the rootfs into the correct place in the internal memory of the board:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo radxa/Linux_Upgrade_Tool_v1.21/upgrade_tool di linuxroot debian.ext4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reboot the board and log in with the credentials you set before.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;prepare-the-sd-card&#34;&gt;Prepare the SD Card&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;On your laptop&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;partitions&#34;&gt;Partitions&lt;/h3&gt;

&lt;p&gt;The SD card partition scheme must be as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One 1G partition for /boot&lt;/li&gt;
&lt;li&gt;One 5G partition for rootfs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Insert the SD card and check the device name using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dmesg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/partitions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In these examples we asume /dev/mmcblk1 to be the SD card.&lt;/p&gt;

&lt;p&gt;Use fdisk to create the partitions as explained above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After partitioning the SD, create an EXT2 filesystem on the boot partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs.ext2 /dev/sdb2
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rootfs-partition&#34;&gt;Rootfs Partition&lt;/h3&gt;

&lt;p&gt;Using dd, copy the rootfs partition created before to the sdcard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=rootfs.ext4 of=/dev/sdb2
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;boot-partition&#34;&gt;Boot Partition&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Insert the sdcard in the development board. Mount the first (boot) partition at /boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/mmcblk1p1 /boot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the generation of the boot files, we will use flash-kernel. flash-kernel is a script which will put the kernel and initramfs in the boot location of embedded devices that don&amp;rsquo;t load the kernel and initramfs directly from /boot.&lt;/p&gt;

&lt;p&gt;The Radxa Rock2 was not supported by flash-kernel. I submited a patch within a bug report:
&lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=868166&#34; target=&#34;_blank&#34;&gt;flash-kernel bug report&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since the linux kernel did support the board, fixing this was quite straightforward. The patch consisted on adding an entry for the Rock2 to /usr/share/flash-kernel/db/all/db:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Machine: Radxa Rock 2 Square
Kernel-Flavors: armmp armmp-lpae
DTB-Id: rk3288-rock2-square.dtb
Boot-Script-Path: /boot/boot.scr
U-Boot-Script-Name: bootscr.uboot-generic
Required-Packages: u-boot-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install flash-kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flash-kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the debian kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-cache search linux-image
sudo apt-get install linux-image-4.11.0-2-armmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The installation of the kernel will copy the kernel image and the initramfs on /boot. In addition to this, the installation process will invoke flash-kernel which will install the boot script and the device tree binary on the same location:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@absinthe:/boot$ ls
boot.scr               dtb-4.11.0-2-armmp         System.map-4.11.0-2-armmp
config-4.11.0-2-armmp  dtbs                       vmlinuz-4.11.0-2-armmp
dtb                    initrd.img-4.11.0-2-armmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Umount the sdcard partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo umount /boot
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debian-s-u-boot&#34;&gt;Debian&amp;rsquo;s U-Boot&lt;/h3&gt;

&lt;p&gt;Download Debian u-boot from GitHub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://anonscm.debian.org/git/collab-maint/u-boot.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configure and build:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make rock2_defconfig
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After succesfully building the source, two binaries were generated:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u-boot.bin&lt;/li&gt;
&lt;li&gt;spl/u-boot-spl.bin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Rockchip SoCs bootrom needs u-boot to be flashed to the SD card:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In a special format called IDB&lt;/li&gt;
&lt;li&gt;With offset 0x40 block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to generate the IDB image, use the mkimage tool provided by u-boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tools/mkimage -n rk3288 -T rksd -d spl/u-boot-spl.bin rk3288_idb.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the rock2 board, the kernel setting CONFIG_ROCKCHIP_SPL_BACK_TO_BROM is by default set to 1. This means that the u-boot binary must be appended to the IDB image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat u-boot.bin &amp;gt;&amp;gt; rk3288_idb.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete image must be now flashed to offset 0x40 on the SD card (e.g. seek=64 as dd parameter):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=rk3288_idb.img of=/dev/mmcblk1 seek=64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this way worked, the right approach is to have a debian package supporting the board.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO u-boot patch for Rock2 support&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;boot-from-the-sd-card&#34;&gt;Boot from the SD Card&lt;/h2&gt;

&lt;p&gt;The sdcard is now ready. In a nutshell, we did the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Generating and installing all necessary boot files on the development board, with the first sdcard partition mounted on /boot&lt;/li&gt;
&lt;li&gt;Creating a debian file system and copying it to the second sdcard partition&lt;/li&gt;
&lt;li&gt;Building u-boot and copying the files to offset 0x40 on the sdcard.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Integration Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The board is able to boot both from internal memory and from a SD card: if a SD card is inserted, it will check first there for a bootable system. However, this is not true for u-boot: even if the SD card is equiped with a running u-boot, the board will always boot from the u-boot stored on the internal memory. In order to solve this, allowing the rock2 to use the u-boot on the SD card, we need to &amp;ldquo;brick&amp;rdquo; the board, zeroing the memory position where u-boot is located.&lt;/p&gt;

&lt;p&gt;I found some useful information &lt;a href=&#34;http://git.denx.de/?p=u-boot.git;a=blob;f=doc/README.rockchip;h=e0572c80b9c7d6e22bfc695d0d73fde74f6789d5;hb=df61a74e6845ec9bdcdd48d2aff5e9c2c6debeaa&#34; target=&#34;_blank&#34;&gt;here.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The firefly board refered to this README has the same architecture as the Rock2. Among other things, on this README is described how to remove the existing u-boot from the board, thus allowing to boot from a custom u-boot on the SD card:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=/dev/mmcblk0 bs=1M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the location where u-boot is stored in the internal flash of the board is zeroised, the board won&amp;rsquo;t be able to boot from there anymore, trying to find a suitable u-boot on the sdcard.&lt;/p&gt;

&lt;p&gt;Connect your laptop to the serial port of the board and use minicom to see the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo minicom /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert the sdcard and reboot the integration board. Debian u-boot will boot the debian kernel and the debian system will start.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux buster/sid absinthe ttyS2

absinthe login: 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dual Boot Linux/ChromeOS on the Asus Chromebook Flip C101PA</title>
      <link>https://eramons.github.io/techblog/post/depthcharge_asuschromebook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/depthcharge_asuschromebook/</guid>
      <description>

&lt;p&gt;&lt;em&gt;WORK IN PROGRESS: Coming next&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Context:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Coreboot&lt;/li&gt;
&lt;li&gt;Depthcharge payload&lt;/li&gt;
&lt;li&gt;Debian kernel in vb (verified boot) format&lt;/li&gt;
&lt;li&gt;Support for &amp;ldquo;Legacy boot&amp;rdquo; by pressing Ctrl-L&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Be able to dual-boot ChromeOS and Debian (or another Linux distribution) on the chromebook&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ARM Chromebooks ship with the Coreboot bootloader and use Depthcharge as the payload.&lt;/p&gt;

&lt;h2 id=&#34;1-build-depthcharge&#34;&gt;1. Build depthcharge&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;References and links:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.coreboot.org&#34; target=&#34;_blank&#34;&gt;Coreboot Website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coreboot/depthcharge&#34; target=&#34;_blank&#34;&gt;Depthcharge Source Code&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
