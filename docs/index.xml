<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Technical Blog on Small Technical Blog</title>
    <link>https://eramons.github.io/techblog/</link>
    <description>Recent content in Small Technical Blog on Small Technical Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017-2020 E. Ramon</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/techblog/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>K3s on Raspberry Pi 4</title>
      <link>https://eramons.github.io/techblog/post/k3s/</link>
      <pubDate>Mon, 15 Jun 2020 15:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/k3s/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Set up a minimal Kubernetes cluster on Rapberry Pi 4.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I ordered a new Raspberry Pi 4 a couple of days ago. I already use one at work for automated testing and I think it&amp;rsquo;s pretty cool, but I actually wasn&amp;rsquo;t sure what I wanted it for. After giving it a thought, I decided to install Rancher&amp;rsquo;s K3S distribution on it, turning it to a convenient, low-power-consumption, single-node K8s distribution I can use as a playground.&lt;/p&gt;

&lt;p&gt;To try it out, I would deploy the manifests of my kubecozy project on it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Possibility 1: the Raspberry Pi 4 will be both master and worker&lt;/em&gt;
&lt;em&gt;Possibility 2: the Raspberry Pi 4 will be the master. An older Raspberry Pi 3 will be the worker&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Willing to simplify, I went for the first possibility.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://eramons.github.io/techblog/techblog/img/raspberrypi.jpg&#34; alt=&#34;Raspberry Pi 4 with case&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the Raspberry 4, I will use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Power adapter&lt;/li&gt;
&lt;li&gt;Ethernet cable&lt;/li&gt;
&lt;li&gt;SD card&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Tasks:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Install latest Raspbian on the Raspberry Pi 4&lt;/li&gt;
&lt;li&gt;Install K3S&lt;/li&gt;
&lt;li&gt;Enable 64 bits kernel&lt;/li&gt;
&lt;li&gt;Fix up networking&lt;/li&gt;
&lt;li&gt;Set up the cluster&lt;/li&gt;
&lt;li&gt;Deploy something&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-install-raspbian&#34;&gt;1. Install Raspbian&lt;/h2&gt;

&lt;p&gt;Download latest Raspbian image.&lt;/p&gt;

&lt;p&gt;Unzip:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/raspberrypi$ unzip 2020-02-13-raspbian-buster-lite.zip 
Archive:  2020-02-13-raspbian-buster-lite.zip
  inflating: 2020-02-13-raspbian-buster-lite.img  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy to the sdcard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/raspberrypi$ sudo dd if=2020-02-13-raspbian-buster-lite.img of=/dev/sdb bs=4MB
462+1 records in
462+1 records out
1849688064 bytes (1.8 GB, 1.7 GiB) copied, 133.426 s, 13.9 MB/s

eramon@caipirinha:~/dev/raspberrypi$ sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: find out the device name first, using dmesg. For me, it was /dev/sdb.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To make sure we can connect to the Raspberry Pi 4 via ssh, we need to manually add a &lt;em&gt;SSH&lt;/em&gt; file to the SDCard.&lt;/p&gt;

&lt;p&gt;Mount the sdcard first partition and add the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/raspberrypi$ sudo mount /dev/sdb1 mnt/
eramon@caipirinha:~/dev/raspberrypi$ cd mnt/
eramon@caipirinha:~/dev/raspberrypi/mnt$ sudo touch SSH
eramon@caipirinha:~/dev/raspberrypi/mnt$ cd ..
eramon@caipirinha:~/dev/raspberrypi$ sudo umount mnt
eramon@caipirinha:~/dev/raspberrypi$ sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert the SD Card in the Raspberry Pi 4. Connect the power adapter and the ethernet cable.&lt;/p&gt;

&lt;p&gt;Next, I have to find out the IP of the Raspberry Pi 4. The easiest way was to connect to my home router and check the DHCP leases list.&lt;/p&gt;

&lt;p&gt;Once found out, connect to the Raspberry Pi 4 over ssh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/raspberrypi$ ssh pi@192.168.1.134
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: default username/password is pi/raspberry&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-install-k3s&#34;&gt;2. Install K3S&lt;/h2&gt;

&lt;p&gt;Get K3S latest binary (make sure to get the armhf version):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ wget https://github.com/rancher/k3s/releases/download/v1.17.4%2Bk3s1/k3s-armhf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rename binary and change file mode to make it executable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo mv k3s-armhf /usr/local/bin/k3s
pi@raspberrypi:~ $ chmod +x /usr/local/bin/k3s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avoid having to use sudo to invoke k3s:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo chmod 644 /etc/rancher/k3s/k3s.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The container runtime i.e. docker is automatically installed with K3s. Don&amp;rsquo;t install it manually or this will mess up the iptables configuration.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: I actually did that mistake. The sympthom was that the pods weren&amp;rsquo;t able to communicate with each other. I was able to fix it by uninstalling iptables, uninstalling docker.io, installing nftables and restarting.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Show cluster info:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ k3s kubectl cluster-info
Kubernetes master is running at https://127.0.0.1:6443
CoreDNS is running at https://127.0.0.1:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
Metrics-server is running at https://127.0.0.1:6443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run k3s as a daemon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo vi /etc/systemd/system/k3s.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content of the file should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=Lightweight Kubernetes
Documentation=https://k3s.io
After=network-online.target

[Service]
Type=notify
ExecStart=/usr/local/bin/k3s server
KillMode=process
Delegate=yes
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
TimeoutStartSec=0
Restart=always
RestartSec=5s

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Restart the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo systemctl daemon-reload
pi@raspberrypi:~ $ sudo systemctl start k3s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order for the service to start automatically after a reboot, you have to enable the service as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo systemctl enable k3s
Created symlink /etc/systemd/system/multi-user.target.wants/k3s.service â†’ /lib/systemd/system/k3s.service.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-networking&#34;&gt;3. Networking&lt;/h2&gt;

&lt;p&gt;Enable wireless networking:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo raspi-config 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Follow the instructions to activate the wifi network interface and get the new IP. Afterwards, configure a  static lease in the home network settings so the raspi will always get the same address.&lt;/p&gt;

&lt;h2 id=&#34;4-enable-64-bits-kernel&#34;&gt;4. Enable 64 bits kernel&lt;/h2&gt;

&lt;p&gt;I found out many available docker images are available for arm 64 bits only. The raspi 4 supports 64 bits, however for Raspbian there was still only the 32-bits version available. After a little research I found a guide to enable a 64 bits kernel on the 32-bits distribution.&lt;/p&gt;

&lt;p&gt;Enable 64 bits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo su
root@raspberrypi:/home/pi# echo &#39;arm_64bit=1&#39; &amp;gt;&amp;gt; /boot/config.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the modification:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ uname -a
Linux raspberrypi 4.19.97-v8+ #1294 SMP PREEMPT Thu Jan 30 13:27:08 GMT 2020 aarch64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reboot the raspberry pi and disconnect the ethernet cable. Afterwards, the k3s service will start automatically and the device will be accessible over wi-fi.&lt;/p&gt;

&lt;h2 id=&#34;5-set-up-the-cluster&#34;&gt;5. Set up the cluster&lt;/h2&gt;

&lt;p&gt;I oriented myself on previous work building a home-made cluster to know which do I have to set up:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install cert-manager&lt;/li&gt;
&lt;li&gt;Set-up nfs for persistent volumes &lt;em&gt;The package nfs-common was already available on raspbian.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Set-up ClusterIssuer&lt;/li&gt;
&lt;li&gt;Network overlay &lt;em&gt;Flannel was already automatically installed when running the K3s installation script.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-install-cert-manager&#34;&gt;5.1. Install cert-manager&lt;/h3&gt;

&lt;p&gt;Install cert-manager using manifests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~/kubecozy $ sudo k3s kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.14.3/cert-manager.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check that it&amp;rsquo;s running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~/kubecozy $ sudo k3s kubectl get pods -n cert-manager
NAME                                      READY   STATUS    RESTARTS   AGE
cert-manager-77fcb5c94-rz8kd              1/1     Running   0          64s
cert-manager-cainjector-8fff85c75-nsgsx   1/1     Running   0          64s
cert-manager-webhook-54647cbd5-dtlnk      1/1     Running   0          63s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It seemed to be working.&lt;/p&gt;

&lt;h3 id=&#34;5-2-set-up-kubectl-client&#34;&gt;5.2 Set-up kubectl client&lt;/h3&gt;

&lt;p&gt;To avoid having to ssh to the device to manage the cluster, I copied kubeconfig content from &lt;em&gt;/etc/rancher/k3s/k3s.yaml&lt;/em&gt; and insert it into &lt;em&gt;/home/eramon/.kube/config&lt;/em&gt; to be able to access the cluster directly from my client machine. Remember to change the IP as necessary inside the file.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: I already had kubectl installed&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-deploy-example-application&#34;&gt;6. Deploy example application&lt;/h2&gt;

&lt;p&gt;To try out the cluster, I wanted to deploy my kubecozy project (see &lt;a href=&#34;https://eramons.github.io/techblog/post/kubernetes_cluster/&#34; target=&#34;_blank&#34;&gt;Home-made K8s cluster&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;If I did it right the first time, to deploy the same application in another cluster should be quite straightforward.&lt;/p&gt;

&lt;p&gt;So I checked out my previous work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev$ git clone https://github.com/eramons/kubecozy.git
eramon@caipirinha:~/dev$ cd kubecozy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However there were still some modifications and changes I had to go through due to the new architecture and the new distribution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modify ingress to use traefik instead of nginx&lt;/li&gt;
&lt;li&gt;Build a new cozy-stack docker image for arm and find arm versions for mailhog and couchdb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And some customizations which are deployment-dependent and therefore not part of the manifests:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set up the cluster issuer&lt;/li&gt;
&lt;li&gt;Set up the cloudflare token&lt;/li&gt;
&lt;li&gt;Set up the persistent volumes and persistent volume claims&lt;/li&gt;
&lt;li&gt;Generate the secrets&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-1-remove-nginx-and-set-up-ingress&#34;&gt;6.1. Remove nginx and set up ingress&lt;/h3&gt;

&lt;p&gt;In K3s, Traefik comes already installed as default ingress controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ kubectl get svc traefik --namespace kube-system -w
NAME      TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE
traefik   LoadBalancer   10.43.213.9   192.168.1.131   80:31368/TCP,443:30018/TCP   213d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change kustomization file to remove the nginx ingress: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/arm64v8/kustomization.yaml&#34; target=&#34;_blank&#34;&gt;arm64v8/kustomization.yaml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Change the cozy-ingress.yaml.example removing the nginx annotations: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/arm64v8/cozy-ingress.yaml.example&#34; target=&#34;_blank&#34;&gt;arm64v8/cozy-ingress.yaml.example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Customize cozy-ingress.yaml, changing the hostnames:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ cp cozy-ingress.yaml.example cozy-ingress.yaml
eramon@caipirinha:~/dev/kubecozy$ vi cozy-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-2-new-docker-images-for-arm&#34;&gt;6.2 New docker images for arm&lt;/h3&gt;

&lt;p&gt;The docker images I used originally do not work on an arm architecture. I had to do some more work here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a new cozy-stack docker image for arm64v8. Build it on the raspi and push it to dockerhub.&lt;/li&gt;
&lt;li&gt;Change the deployment file to use the new image instead of the amd64 one: &lt;em&gt;eramon/cozy-stack-arm64v8&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Change the couchdb deployment file to use the arm64 version: &lt;em&gt;arm64v8/couchdb:3.1.0&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Change the mailhog deployment file to use an arm64 version: &lt;em&gt;albertsai/mailhog&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;New deployment manifests:
&lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/arm64v8&#34; target=&#34;_blank&#34;&gt;arm64v8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;New Dockerfile for cozy-stack on arm64v8:
&lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/arm64v8/docker/Dockerfile&#34; target=&#34;_blank&#34;&gt;arm64v8/docker/Dockerfile&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-3-cloudflare-token&#34;&gt;6.3 Cloudflare token&lt;/h3&gt;

&lt;p&gt;Customize cloudflare.yaml, providing the cloudflare api token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ cp cloudflare.yaml.example cloudflare.yaml
eramon@caipirinha:~/dev/kubecozy$ vi cloudflare.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cloudflare.yaml is not part of the kustomize file, since is cluster specific. So I had to apply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ kubectl apply -f cloudflare.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-4-cluster-issuer&#34;&gt;6.4 Cluster issuer&lt;/h3&gt;

&lt;p&gt;Customize letsencrypt-prod.yaml, changing the e-mail address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ cp letsencrypt-prod.yaml.example letsencrypt-prod.yaml
eramon@caipirinha:~/dev/kubecozy$ vi letsencrypt-prod.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-5-persistent-volumes&#34;&gt;6.5 Persistent volumes&lt;/h3&gt;

&lt;p&gt;Customize pv files, modifying IP, path and size:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ cp couchdb-nfs-pv.yaml.example couchdb-nfs-pv.yaml
eramon@caipirinha:~/dev/kubecozy$ vi couchdb-nfs-pv.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ cp cozy-nfs-pv.yaml.example cozy-nfs-pv.yaml
eramon@caipirinha:~/dev/kubecozy$ vi cozy-nfs-pv.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The persistent volumes are not part of kustomize (since there are cluster specific), so I had to apply the manifests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ kubectl apply -f cozy-nfs-pv.yaml
eramon@caipirinha:~/dev/kubecozy$ kubectl apply -f couchdb-nfs-pv.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-6-secrets&#34;&gt;6.6 Secrets&lt;/h3&gt;

&lt;p&gt;The secrets must be generated manually, following the same process described on my previous post, using the new cozy-docker arm64v8 image instead of the amd64 one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ touch cozy-admin-passphrase
eramon@caipirinha:~/dev/kubecozy$ sudo docker run --rm -it -p 8080:8080 -v /home/pi/kubecozy/cozy-admin-passphrase:/home/cozy/cozy-admin-passphrase eramon/cozy-stack-arm64v8 cozy-stack config passwd cozy-admin-passphrase
eramon@caipirinha:~/dev/kubecozy$ kubectl create secret generic cozy-admin-passphrase-secret --from-file=cozy-admin-passphrase
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ mkdir vault
eramon@caipirinha:~/dev/kubecozy$ sudo docker run --rm -it -p 8080:8080 -v /home/pi/kubecozy/vault:/home/cozy/vault eramon/cozy-stack-arm64v8 cozy-stack config gen-keys /home/cozy/vault
eramon@caipirinha:~/dev/kubecozy$ kubectl create secret generic cozy-vault-secret --from-file=vault/vault.enc --from-file=vault/vault.dec
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ echo -n &amp;quot;admin&amp;quot; &amp;gt; dbusername
eramon@caipirinha:~/dev/kubecozy$ echo -n `pwgen -s -1 16` &amp;gt; dbpassphrase
eramon@caipirinha:~/dev/kubecozy$ kubectl create secret generic db-secret --from-file=dbusername --from-file=dbpassphrase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubecozy$ k3s kubectl apply -k .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cozy application previously deployed on my home-made bare-metal K8s cluster was now working on the K3s cluster on the Raspberry Pi 4, using the same manifests - after the minimal modifications described.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://k3s.io/&#34; target=&#34;_blank&#34;&gt;Lightweit Kubernetes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rancher/k3s/releases/tag/v1.17.4+k3s1&#34; target=&#34;_blank&#34;&gt;K3S Releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rancher/k3s/issues/1597&#34; target=&#34;_blank&#34;&gt;Issue with iptables&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.michaelburch.net/blog/Kubernetes-on-Raspberry-Pi-with-K3s.html&#34; target=&#34;_blank&#34;&gt;Kubernetes on Raspberry Pi with K3s&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Self-hosted cozy on K8s</title>
      <link>https://eramons.github.io/techblog/post/cozy/</link>
      <pubDate>Thu, 28 May 2020 17:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/cozy/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Deploy cozy on my homemade kubernetes cluster&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The K8s homemade cluster on baremetal was meant to be just an exercise and not a permanent setup. Still, I needed to find something to deploy on it :)&lt;/p&gt;

&lt;p&gt;I decided to try out Cozy Cloud deploying software and dependencies as containers in my K8s cluster.&lt;/p&gt;

&lt;p&gt;Cozy is a personal, free and self-hostable cloud platform, written in Go.&lt;/p&gt;

&lt;h3 id=&#34;milestones&#34;&gt;Milestones&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pre-requisites:&lt;/strong&gt; make sure the infrastructure is ready&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cozy Software:&lt;/strong&gt; installation, dependencies and configuration&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Images:&lt;/strong&gt; which one are available and which new ones we need&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K8s Configuration:&lt;/strong&gt; write manifests for deployment in the cluster&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cozy instance:&lt;/strong&gt; create a new cozy instance and test it&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-pre-conditions&#34;&gt;1. Pre-conditions&lt;/h2&gt;

&lt;h3 id=&#34;1-1-infrastructure&#34;&gt;1.1. Infrastructure&lt;/h3&gt;

&lt;p&gt;Following pre-requisites must be fullfilled by the infrastructure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cozy needs to be served over HTTPS, which means it needs a reverse proxy in front of it.&lt;/li&gt;
&lt;li&gt;Cozy needs a full domain name for the instance: &lt;em&gt;instance.example.com&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Cozy uses one domain name per application: &lt;em&gt;app.instance.example.com&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Currently the list of apps is: home, settings, drive, photos, onboarding&lt;/li&gt;
&lt;li&gt;A wildcard certificate covering &lt;em&gt;*.cozy.example.com&lt;/em&gt; (CN) and &lt;em&gt;cozy.example.com&lt;/em&gt; (SAN) is needed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;According to the documentation, the domain zone should be configured like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;instance&amp;gt; 1h IN A &amp;lt;my external IP&amp;gt; 
   *.&amp;lt;instance&amp;gt; 1h IN CNAME &amp;lt;instance&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use cloudflare for DNS configuration.&lt;/p&gt;

&lt;p&gt;TLS certificate issuance, wildcard certificates and reverse proxy are requirements which must be fullfilled by the K8s cluster (see next section).&lt;/p&gt;

&lt;p&gt;It remained the issue of the internal hostname resolution. My internet box was not able to properly route requests to its own external IP address from inside the internal network. To fix this I needed to modify the internal DNS resolution: from inside the network, the IP for &lt;em&gt;cozy.example.com&lt;/em&gt; and &lt;em&gt;*.cozy.example.com&lt;/em&gt; must be the one of my worker&amp;rsquo;s node (since my ingress controller is deployed as a DaemonSet).&lt;/p&gt;

&lt;p&gt;To find out how did I set up the DNS configuration on the home network, see:
&lt;a href=&#34;https://eramons.github.io/techblog/post/dns/&#34; target=&#34;_blank&#34;&gt;DNS Configuration for K8s&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-2-k8s-cluster&#34;&gt;1.2. K8s Cluster&lt;/h3&gt;

&lt;p&gt;Following pre-conditions must be fullfilled by the K8s cluster:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To have &lt;strong&gt;nginx-ingress&lt;/strong&gt; available as reverse-proxy&lt;/li&gt;
&lt;li&gt;To have &lt;strong&gt;cert-manager&lt;/strong&gt; deployed on the cluster&lt;/li&gt;
&lt;li&gt;A ClusterIssuer with &lt;strong&gt;DNS01&lt;/strong&gt; resolution, in order to support wildcard certificates&lt;/li&gt;
&lt;li&gt;To be able to serve &lt;strong&gt;persistent volume claims&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;In order to support nfs persistent volumes: to have &lt;strong&gt;nfs-common&lt;/strong&gt; installed on all worker nodes of the cluster&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-3-k8s-client-and-applications&#34;&gt;1.3. K8s Client and Applications&lt;/h3&gt;

&lt;p&gt;Following software and tools must be available on the client machine (laptop):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To have &lt;strong&gt;kubectl&lt;/strong&gt; installed on my laptop and the credentials to the k8s cluster stored under &lt;em&gt;.kube/config&lt;/em&gt; on the home directory&lt;/li&gt;
&lt;li&gt;To have &lt;strong&gt;helm&lt;/strong&gt; installed on my laptop&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the pre-requisite is to have a K8s cluster available to deploy in and to have the necessary tools on the client to make the deployments.&lt;/p&gt;

&lt;p&gt;I addressed all these topics on my previous post:
&lt;a href=&#34;https://eramons.github.io/techblog/post/kubernetes_cluster/&#34; target=&#34;_blank&#34;&gt;Home-made K8s cluster&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-cozy&#34;&gt;2. Cozy&lt;/h2&gt;

&lt;p&gt;According to the developer documentation, there are following ways of install and run cozy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;using cozy-customized debian packages (non-debian official) following the self-hosting guide&lt;/li&gt;
&lt;li&gt;self build the application&lt;/li&gt;
&lt;li&gt;run a docker developer cozy image, which all dependencies and configuration included&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The official way seems to be to use the debian packages. This way install cozy-stack and their dependencies and an application called cozy-coclyco which manages cozy instances and SSL certificates. During the installation, the packages prompt the user to provide usernames and passwords and generate the configuration.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t need coclyco, since my cluster uses cert-manager and nginx-ingress for SSL termination and issuance and renewal of TLS server certificates. I figured out that the only part of cozy I needed was actually the cozy-stack binary application.&lt;/p&gt;

&lt;p&gt;Basing on this premise, I identified applications and dependencies to be considered:&lt;/p&gt;

&lt;h3 id=&#34;2-1-applications&#34;&gt;2.1. Applications&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cozy-stack&lt;/strong&gt;: the core server of the cozy platform, which consists of a single process&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;couchdb&lt;/strong&gt;: database for storing the cozy application data&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-dependencies-cozy-stack&#34;&gt;2.2. Dependencies (cozy-stack)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mailhog&lt;/strong&gt;: cozy-stack needs a smtp server in order to work. &lt;em&gt;Mailhog&lt;/em&gt; is an e-mail testing tool for developers. I intended to use mailhog instead of configuring a smtp server.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;imagemagick&lt;/strong&gt;: image manipulation program binaries&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-3-cozy-configuration&#34;&gt;2.3. Cozy Configuration&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;cozy-stack&lt;/em&gt; binary and its command &lt;em&gt;serve&lt;/em&gt; allow to pass flags as configuration options. As an alternative, a &lt;em&gt;cozy.yaml&lt;/em&gt; configuration file can be placed under &lt;em&gt;/etc/cozy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I prefered to use a config file in order to keep the configuration separated from the container image.&lt;/p&gt;

&lt;p&gt;See my &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/config/cozy.yaml&#34; target=&#34;_blank&#34;&gt;cozy.yaml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go over the most important configuration settings:&lt;/p&gt;

&lt;h4 id=&#34;service-hosts-port&#34;&gt;Service hosts &amp;amp; port&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;host: 0.0.0.0 
port: 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The bind address and the port where cozy-stack will listen for connections. Important to use 0.0.0.0 and NOT localhost, otherwise the application will only bind to 127.0.0.1.&lt;/p&gt;

&lt;h4 id=&#34;admin-interface&#34;&gt;Admin interface&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;admin:
  host: localhost 
  port: 6060
  secret_filename: cozy-admin-passphrase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The admin interface to send requests to cozy-stack. The cozy admin password is stored encrypted in the filesystem. It must be generated beforehand using the cozy-stack binary (see K8s configuration: secrets).&lt;/p&gt;

&lt;h4 id=&#34;database&#34;&gt;Database&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;couchdb:
  url: http://{{.Env.COUCHDB_USERNAME}}:{{.Env.COUCHDB_PASSPHRASE}}@couchdb:5984/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Couchdb stores the cozy application data.&lt;/p&gt;

&lt;p&gt;The environment variables must be provided later in the cozy-stack deployment manifest.&lt;/p&gt;

&lt;h4 id=&#34;storage&#34;&gt;Storage&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;fs:
  url: file://localhost/var/lib/cozy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filesystem path for the storage of user data: photos, documents, etc. Later we&amp;rsquo;ll see on this path a nfs share folder will be mounted.&lt;/p&gt;

&lt;h4 id=&#34;vault&#34;&gt;Vault&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;vault:
  credentials_encryptor_key: /etc/cozy/keys/vault.enc
  credentials_decryptor_key: /etc/cozy/keys/vault.dec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cozy encrypts user credentials. The generation of the encryption and decryption keys must be done before the cozy-stack is started (see K8s configuration: secrets).&lt;/p&gt;

&lt;h4 id=&#34;smtp-server&#34;&gt;SMTP Server&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;mail:
  host: smtp 
  port: 1025 
  disable_tls: true 
  skip_certificate_validation: true 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apparently having a working SMTP server up und running is a requirement for cozy-stack. I wasn&amp;rsquo;t actually interested in my cozy writting me e-mails. In the cozy documentation, I read that the cozy development image use &lt;em&gt;Mailhog&lt;/em&gt;. The e-mails can be viewed on the browser but are not actually sent. I liked this approach, so I did the same.&lt;/p&gt;

&lt;p&gt;The hostname &lt;em&gt;smtp&lt;/em&gt; is the dns name of a K8s service we&amp;rsquo;ll define later, which will point to the mailhog instance.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: mailhog does not allow to configure a username and a password. Otherwise, it fails with an &amp;ldquo;unencrypted connection&amp;rdquo; error&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-docker&#34;&gt;3. Docker&lt;/h2&gt;

&lt;h3 id=&#34;3-1-available-docker-images&#34;&gt;3.1 Available Docker Images&lt;/h3&gt;

&lt;p&gt;From the applications identified in the last section:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;couchdb&lt;/strong&gt; and &lt;strong&gt;mailhog&lt;/strong&gt; have official docker images available&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;imagemagick&lt;/strong&gt; is available as debian package (and should be included on the cozy-stack docker image)&lt;/li&gt;
&lt;li&gt;for &lt;strong&gt;cozy-stack&lt;/strong&gt; I decided to create my own docker image&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-docker-image-for-cozy-stack&#34;&gt;3.2 Docker image for cozy-stack&lt;/h3&gt;

&lt;p&gt;The cozy-stack is a go binary. There was two options for writting a docker image:&lt;/p&gt;

&lt;p&gt;a)   Build the go binary inside the container&lt;/p&gt;

&lt;p&gt;b)   Pull the binary directly from github inside the container&lt;/p&gt;

&lt;p&gt;I went for the second option. The Dockerfile looks like follows:
&lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/docker/Dockerfile&#34; target=&#34;_blank&#34;&gt;Dockerfile&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a closer look at the Dockerfile:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The basis image is debian (bullseye)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Imagemagick&lt;/em&gt; is installed as a dependency&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;cozy&lt;/em&gt; user is created&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;workdir&lt;/em&gt; is the home directory of the &lt;em&gt;cozy&lt;/em&gt; user&lt;/li&gt;
&lt;li&gt;The application will be executed as &lt;em&gt;cozy&lt;/em&gt; user (and therefore NOT as root)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once ready, I build the image and push it to dockerhub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker login
docker image build -t eramon/cozy-stack .
docker push eramon/cozy-stack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;LATER: instead of pushing the image manually, I should configure dockerhub and github for automatic building of the docker image when a commit to the Dockerfile is done.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-k8s-configuration&#34;&gt;4. K8s configuration&lt;/h2&gt;

&lt;p&gt;Now that I had the docker images an the cozy-stack configuration file prepared, the next step was to deploy the applications.&lt;/p&gt;

&lt;p&gt;For deploying cozy in K8s, I wrote yaml manifests for:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The services&lt;/li&gt;
&lt;li&gt;The secrets&lt;/li&gt;
&lt;li&gt;The config map&lt;/li&gt;
&lt;li&gt;The persistent volume claims&lt;/li&gt;
&lt;li&gt;The cluster issuer&lt;/li&gt;
&lt;li&gt;The ingress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All yaml files are available under my &lt;a href=&#34;https://github.com/eramons/kubecozy&#34; target=&#34;_blank&#34;&gt;kubecozy&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;4-1-services&#34;&gt;4.1 Services&lt;/h3&gt;

&lt;p&gt;A K8s &lt;strong&gt;Service&lt;/strong&gt; is an abstract way to expose an application running on a set of pods as a network service.&lt;/p&gt;

&lt;p&gt;I defined four services:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The cozy-stack service: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/cozy-stack-service.yaml&#34; target=&#34;_blank&#34;&gt;cozy-stack-service.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The couchdb service: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/couchdb-service.yaml&#34; target=&#34;_blank&#34;&gt;couchdb-service.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The smtp-server service: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/smtp-service.yaml&#34; target=&#34;_blank&#34;&gt;smtp-service.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The mailhog webserver service: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/mailhog-service.yaml&#34; target=&#34;_blank&#34;&gt;mailhog-service.yaml&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;4-2-secrets&#34;&gt;4.2 Secrets&lt;/h3&gt;

&lt;p&gt;Kubernetes &lt;strong&gt;Secrets&lt;/strong&gt; let you store and manage sensitive information, such as passwords, tokens and keys.&lt;/p&gt;

&lt;h4 id=&#34;4-2-1-admin-passphrase&#34;&gt;4.2.1 admin passphrase&lt;/h4&gt;

&lt;p&gt;The &lt;em&gt;cozy-stack&lt;/em&gt; binary is necessary for generate the admin password. However my cozy-stack image executes &lt;em&gt;cozy serve&lt;/em&gt; at the end, what does not work before generating the admin password. The solution was to run the docker image overriding the default CMD to generate the admin passphrase instead starting serve, mounting the new generated passphrase to an empty file on the host:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ touch cozy-admin-passphrase
eramon@caipirinha:~/dev/kubernetes$ docker run --rm -it -p 8080:8080 -v /home/eramon/dev/kubernetes/cozy-admin-passphrase:/home/cozy/cozy-admin-passphrase eramon/cozy-stack cozy-stack config passwd cozy-admin-passphrase
Hashed passphrase will be written in /home/cozy/cozy-admin-passphrase
Passphrase: 
Confirmation:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I created the K8s secret:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ kubectl create secret generic cozy-admin-passphrase-secret --from-file=cozy-admin-passphrase
secret/cozy-admin-passphrase-secret created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This secret will be mounted afterwards in the expected location on the &lt;em&gt;cozy-stack&lt;/em&gt; pod, via the deployment manifest.&lt;/p&gt;

&lt;h4 id=&#34;4-2-2-vault-keys&#34;&gt;4.2.2 vault keys&lt;/h4&gt;

&lt;p&gt;I followed the same procedure to generate the vault keys&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ docker run --rm -it -p 8080:8080 -v /home/eramon/dev/kubernetes/vault:/home/cozy/vault eramon/cozy-stack cozy-stack config gen-keys /home/cozy/vault
keyfiles written in:
  /home/cozy/vault.enc
  /home/cozy/vault.dec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate the K8s secret for the vault keys:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ kubectl create secret generic cozy-vault-secret --from-file=vault/vault.enc --from-file=vault/vault.dec
secret/cozy-vault-secret created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This secret will be mounted afterwards in the configured location on the &lt;em&gt;cozy-stack&lt;/em&gt; pod, via the deployment manifest.&lt;/p&gt;

&lt;h4 id=&#34;4-2-3-couchdb-credentials&#34;&gt;4.2.3 couchdb credentials&lt;/h4&gt;

&lt;p&gt;I generated a secret for the couchdb username and password:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ echo -n &amp;quot;admin&amp;quot; &amp;gt; dbusername
eramon@caipirinha:~/dev/kubernetes$ echo -n `pwgen -s -1 16` &amp;gt; dbpassphrase 
eramon@caipirinha:~/dev/kubernetes$ kubectl create secret generic db-secret --from-file=dbusername --from-file=dbpassphrase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This secret must be used to set the environment variables in the couchdb and cozy-stack deployment afterwards.&lt;/p&gt;

&lt;h3 id=&#34;4-3-configmap&#34;&gt;4.3 ConfigMap&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ConfigMaps&lt;/strong&gt; allow to decouple configuration artifacts from image content to keep containerized applications portable.&lt;/p&gt;

&lt;h4 id=&#34;4-3-1-ingress-nginx-configmap&#34;&gt;4.3.1. ingress-nginx configmap&lt;/h4&gt;

&lt;p&gt;For customising the nginx configuration I mainly used annotations. The annotations allow to provide configuration customization on the virtual host level, that&amp;rsquo;s way they are included in the ingress. However at some point I had to struggle with an issue which could not be solved through annotations: I had to deactivate http2. This configuration has to be done on the server level. For that I used a configmap:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/ingress-nginx-configmap.yaml&#34; target=&#34;_blank&#34;&gt;ingress-nginx-configmap.yaml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: apparently nginx has an issue with http2. I didn&amp;rsquo;t find an explanation.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-3-2-configmapgenerator&#34;&gt;4.3.2. ConfigMapGenerator&lt;/h3&gt;

&lt;p&gt;As mentioned above, I decided to use a config file for rather than having flags passed as arguments. The file &lt;em&gt;cozy.yaml&lt;/em&gt; would be included in a config map and mounted under &lt;em&gt;/etc/cozy&lt;/em&gt; in the &lt;em&gt;cozy-stack&lt;/em&gt; container.&lt;/p&gt;

&lt;p&gt;To generate the config map, I directly include it in the resource list of kustomization.yaml:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ConfigMaps
configMapGenerator:
- name: cozy-config-map
  files:
  - config/cozy.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-4-persistent-volume-claims&#34;&gt;4.4 Persistent Volume Claims&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;PersistentVolume (PV)&lt;/strong&gt; is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;PersistentVolumeClaim (PVC)&lt;/strong&gt; is a request for storage by a user.&lt;/p&gt;

&lt;p&gt;To store user and application data, we need to use persistent volumes and bind them to the applications through persistent volume claims and volume mounts.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Pre-condition:&lt;/em&gt; the cluster has available persistent volumes&lt;/p&gt;

&lt;p&gt;I created two PVCs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PVC for couchdb (application data): &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/couchdb-pvc.yaml&#34; target=&#34;_blank&#34;&gt;couchdb-pvc.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PVC for cozy-stack (user data): &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/cozy-stack-pvc.yaml&#34; target=&#34;_blank&#34;&gt;cozy-stack-pvc.yaml&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The volume mounts must be configured later on the corresponding deployment manifests.&lt;/p&gt;

&lt;h3 id=&#34;4-5-deployments&#34;&gt;4.5 Deployments&lt;/h3&gt;

&lt;p&gt;Finally, we come to the manifests for the deployments of couchdb, cozy-stack and mailhog.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;Deployment&lt;/strong&gt; provides declarative updates for Pods and ReplicaSets.&lt;/p&gt;

&lt;h4 id=&#34;4-5-1-couchdb&#34;&gt;4.5.1 couchdb&lt;/h4&gt;

&lt;p&gt;Deployment for couchdb (application data): &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/couchdb-deployment.yaml&#34; target=&#34;_blank&#34;&gt;couchdb-deployment.yaml&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The pvc we created before is mounted under &lt;em&gt;/opt/couchdb/data&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The secret containing the couchdb credentials is passed as environment variables&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-5-2-cozy-stack&#34;&gt;4.5.2 cozy-stack&lt;/h4&gt;

&lt;p&gt;Deployment for cozy-stack (user data): &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/cozy-stack-deployment.yaml&#34; target=&#34;_blank&#34;&gt;cozy-stack-deployment.yaml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Taking a closer look at the file we can see:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The configMap containing &lt;em&gt;cozy.yaml&lt;/em&gt; is mounted under &lt;em&gt;/etc/cozy/cozy.yaml&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The persistent volume (nfs) is mounted under &lt;em&gt;/var/lib/cozy&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Since the docker image is NOT ran as root, I needed an init container to mount the persistent volume and set the permissions&lt;/li&gt;
&lt;li&gt;The secret containing the admin-passphrase is mounted under &lt;em&gt;/etc/cozy/cozy-admin-passphrase&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The secret containing the vault keys is mounted under &lt;em&gt;/etc/cozy/vault.enc&lt;/em&gt; and &lt;em&gt;/etc/cozy/vault.dec&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The secret containing the couchdb credentials is passed as environment variables&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-5-3-mailhog&#34;&gt;4.5.3 mailhog&lt;/h4&gt;

&lt;p&gt;Deployment for mailhog (smtp server): &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/mailhog-deployment.yaml&#34; target=&#34;_blank&#34;&gt;mailhog-deployment.yaml&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-6-ingress&#34;&gt;4.6 Ingress&lt;/h3&gt;

&lt;p&gt;An &lt;strong&gt;Ingress&lt;/strong&gt; manages external access to the services in a cluster, typically HTTP.&lt;/p&gt;

&lt;p&gt;The cozy-ingress will expose our services via the nginx ingres controller installed previously:
&lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/cozy-ingress-example.yaml&#34; target=&#34;_blank&#34;&gt;cozy-ingress-example.yaml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The ingress must expose following services, via the nginx ingress controller installed previously:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Forward all requests for *.cozy.example.com (home, drive, settings, photos) to the cozy-stack service&lt;/li&gt;
&lt;li&gt;Forward all requests for cozy.example.com to the cozy-stack service&lt;/li&gt;
&lt;li&gt;Expose the mailhog web interface, to see the e-mails generated by cozy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The TLS certificate is generated and managed by letsencrypt. For that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We include the cluster-issuer annotation, referencing our clusterissuer for let&amp;rsquo;s encrypt&lt;/li&gt;
&lt;li&gt;We set the challenge type annotation to dns01, since this is the mechanism we need to prove full control of our domain cozy.example.com&lt;/li&gt;
&lt;li&gt;We say a secret cozy-tls must be generated for both the main domain and the wildcard one. These will result on a wildcard certificate with cozy.example.com as Subject Alternative Name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Following annotations for the nginx-ingress controller must be included:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set &lt;em&gt;enable-cors&lt;/em&gt; to &lt;em&gt;false&lt;/em&gt;, in order to disable CORS in nginx. The application already handles correctly the Access-Control-Allow-Origin headers&lt;/li&gt;
&lt;li&gt;&lt;em&gt;proxy-body-size&lt;/em&gt;, to set the _client_max_body&lt;em&gt;size&lt;/em&gt; parameter in the nginx configuration. I set it to 1G, according to the example in &lt;a href=&#34;https://github.com/cozy/cozy-coclyco/blob/master/nginx.conf&#34; target=&#34;_blank&#34;&gt;nginx.conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;proxy-connect-&lt;/em&gt;, &lt;em&gt;-read-&lt;/em&gt;, and &lt;em&gt;-send-timeout&lt;/em&gt;. The nginx-ingress controller supports websockets out of the box, however the default values of these attributes is set by default to 60s. That&amp;rsquo;s not enough to backup photos from the mobile phone to the cozy drive. I set it to 2 hours (5200s).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-7-kustomize&#34;&gt;4.7 kustomize&lt;/h3&gt;

&lt;p&gt;In order to ease re-deployments after configuration changes, I used &lt;em&gt;kustomize&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kustomize&lt;/strong&gt; introduces a template-free way to customize application configuration and it&amp;rsquo;s built into the &lt;em&gt;kubectl&lt;/em&gt; command.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/kustomization.yaml&#34; target=&#34;_blank&#34;&gt;kustomization.yaml&lt;/a&gt; file includes all manifests and config files:&lt;/p&gt;

&lt;p&gt;To deploy everything the first time, or after any configuration changes to the cluster or to the application, it&amp;rsquo;s enough to execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl apply -k .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-cozy-instance&#34;&gt;5. Cozy Instance&lt;/h2&gt;

&lt;p&gt;The Dockerfile includes commands for downloading the latest cozy-stack binary, create directories, create a cozy user, set permissions and finally start &lt;em&gt;cozy-stack serve&lt;/em&gt;. The creation of the instances must be done manually after deployment, using the binary. The creation of the instances is not part of the image build.&lt;/p&gt;

&lt;p&gt;For executing the cozy-stack binary to create my cozy instance, I logged into the running container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl exec -it cozy-stack-b6dbd5db8-m58dt /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I created a new cozy-stack instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cozy@cozy-stack-b6dbd5db8-4j2fw:~$ cozy-stack instances add --passphrase cozy --apps home,drive,photos,settings cozy.example.com     
Password:****
Instance created with success for domain cozy.example.com
Password:****
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: another way:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl exec -it &amp;lt;pod&amp;gt; cozy-stack instances add &amp;lt;arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: actually the use of kubectl exec is discouraged. The &amp;ldquo;K8s way&amp;rdquo; would be to use &amp;ldquo;Custom Resource Definition&amp;rdquo; for the creation of the cozy instance&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Show running instances:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cozy@cozy-stack-b6dbd5db8-4j2fw:~$ cozy-stack instances ls
Password:****
cozy.example.com  en  unlimited  onboarded  v27  cozyf55261b8a5b88690387587c7af0bb8af  cozyf55261b8a5b88690387587c7af0bb8af
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this, I was able to connect to my cozy applications under following urls:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cozy.example.com&#34; target=&#34;_blank&#34;&gt;https://cozy.example.com&lt;/a&gt; (redirects to home.cozy.example.com)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://home.cozy.example.com&#34; target=&#34;_blank&#34;&gt;https://home.cozy.example.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://drive.cozy.example.com&#34; target=&#34;_blank&#34;&gt;https://drive.cozy.example.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://photos.cozy.example.com&#34; target=&#34;_blank&#34;&gt;https://photos.cozy.example.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://settings.cozy.example.com&#34; target=&#34;_blank&#34;&gt;https://settings.cozy.example.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To access, I had to log in using the passphrase defined during the instance creation.&lt;/p&gt;

&lt;p&gt;And I could see the e-mails generated by cozy under:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mailhog.cozy.example.com&#34; target=&#34;_blank&#34;&gt;https://mailhog.cozy.example.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I also tried out these client applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On my android mobile phone: &lt;em&gt;cozy drive&lt;/em&gt;, available in the Google Playstore.&lt;/li&gt;
&lt;li&gt;On my debian laptop: the &lt;em&gt;cozy desktop&lt;/em&gt; client&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Looking good :)&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links:&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://cozy.io/&#34; target=&#34;_blank&#34;&gt;Cozy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.cozy.io/en/tutorials/selfhost-debian&#34; target=&#34;_blank&#34;&gt;Self-host in Debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/home&#34; target=&#34;_blank&#34;&gt;Kubernetes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/&#34; target=&#34;_blank&#34;&gt;nginx-ingress annotations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/examples/customization/custom-configuration/&#34; target=&#34;_blank&#34;&gt;nginx-ingress configmap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kustomize.io/&#34; target=&#34;_blank&#34;&gt;Kustomize&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mailhog/MailHog&#34; target=&#34;_blank&#34;&gt;Mailhog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Cozy&#34; target=&#34;_blank&#34;&gt;Archlinux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.cozy.io/en/howTos/sync/linux&#34; target=&#34;_blank&#34;&gt;Desktop client&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://forum.cozy.io/t/unencrypted-connection-storage-limit-nearly-reached/7011&#34; target=&#34;_blank&#34;&gt;cozy.io forum thread&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DNS Configuration for K8s</title>
      <link>https://eramons.github.io/techblog/post/dns/</link>
      <pubDate>Tue, 19 May 2020 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/dns/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Configure DNS, so applications running on the K8S cluster are reachable from the internet and TLS-protected&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Setting up a home made kubernetes cluster is quite straightforward. However, for deploying applications or services accessible from the internet, the configuration capabilities of the standard provider&amp;rsquo;s internet boxes are usually too limited.&lt;/p&gt;

&lt;p&gt;In particular I had the issue of the internal host resolution. My internet box wasn&amp;rsquo;t able to properly route requests to the own external IP address from inside the internal network. And not even in the &lt;em&gt;advanced configuration&lt;/em&gt; was possible to configure static host mapping.&lt;/p&gt;

&lt;p&gt;I wanted to deploy a web application (cozy) on my cluster. In order to have this working, I needed the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A FQDN &lt;em&gt;example.com&lt;/em&gt; resolvable from the internet&lt;/li&gt;
&lt;li&gt;A wildcard SSL certificate covering both &lt;em&gt;example.com&lt;/em&gt; and &lt;em&gt;*.example.com&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;A port forwarding rule for the HTTP and HTTPS ports to the K8S cluster&lt;/li&gt;
&lt;li&gt;A fix IP or a DynDNS service identifying the host IP where the application is running&lt;/li&gt;
&lt;li&gt;An own DNS server with a static host or an entry pointing to the internal IP of the FQDN&lt;/li&gt;
&lt;li&gt;For certmanager and Let&amp;rsquo;s Encrypt, a DNS provider supporting the DNS01 solver mechanism&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-ubiquiti-edgerouter-x-sfp-as-dns-server&#34;&gt;1. Ubiquiti EdgeRouter X (SFP) as DNS server&lt;/h2&gt;

&lt;p&gt;The easiest solution for all this mess would have been to replace the provider&amp;rsquo;s internet box through a router of my own. I had a EdgeRouter X SFP I once bought, but never had time to set up, lying around. However short ago my internet provider replaced the internet box through a new one, featuring 10 GB internet. The EdgeRouter does not support the 10GB internet connection, so to replace the box wasn&amp;rsquo;t an option anymore.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://eramons.github.io/techblog/techblog/img/edgex.jpg&#34; alt=&#34;EdgeX&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So I decided to use the EdgeRouter to work only as a small internal DNS server.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: in this post I&amp;rsquo;m refering to the EdgeRouter as &amp;ldquo;the router&amp;rdquo; even if it&amp;rsquo;s not going to be used as one. The actual router for the host network is what I&amp;rsquo;m refering to as the &amp;ldquo;internet box&amp;rdquo;.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-1-factory-reset&#34;&gt;1.1 Factory reset&lt;/h3&gt;

&lt;p&gt;I followed the instructions in the quick start guide to do a factory reset of the router: press reset button, connect the power cable and wait until a moment until the lights stop blinking.&lt;/p&gt;

&lt;h3 id=&#34;1-2-connect-to-the-router&#34;&gt;1.2 Connect to the router&lt;/h3&gt;

&lt;p&gt;To connect to the router, first I disconnected the wifi on my laptop.&lt;/p&gt;

&lt;p&gt;Then I connected the eth0 port directly to my laptop with a network cable and configured a fix IP on the eth0 port of the laptop as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ifconfig eth0 192.168.1.4 netmask 255.255.255.0 up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this I was able to access the router on the browser under 192.168.1.1.&lt;/p&gt;

&lt;p&gt;Before proceeding with any configuration, I performed a firmware upgrade on the device.&lt;/p&gt;

&lt;h3 id=&#34;1-3-configure-switch-interface&#34;&gt;1.3 Configure switch interface&lt;/h3&gt;

&lt;p&gt;First of all, I had to configure the &lt;em&gt;switch&lt;/em&gt; interface.&lt;/p&gt;

&lt;p&gt;The router has following interfaces:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Two external interfaces: eth0 (normal ethernet port) and eth5 (the SFP port)&lt;/li&gt;
&lt;li&gt;One internal interface &lt;em&gt;switch&lt;/em&gt; with bridged ports eth1, eth2, eth3 and eth3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the &lt;em&gt;Dashboard&lt;/em&gt;, for each interface there is a drop-down button labeled &lt;em&gt;Actions&lt;/em&gt; located on the right. For &lt;em&gt;switch0&lt;/em&gt;, after selecting &lt;em&gt;Config&lt;/em&gt;, I chose to &lt;em&gt;manually define the IP address&lt;/em&gt; and set it to  192.168.1.140 / 24.&lt;/p&gt;

&lt;p&gt;Next thing is to deactivate the DHCP server, so the router does not try to assign IP addresses to other devices in the network. We want the router to act just as a small server and not really as a router. The internet box keeps acting as the DHCP server and router for the home network.&lt;/p&gt;

&lt;p&gt;Under &lt;em&gt;Wizards&lt;/em&gt;, I went to the &lt;em&gt;Basic Setup&lt;/em&gt;. There, under &lt;em&gt;LAN ports&lt;/em&gt;, I deactivated the DHCP Server, unchecking the box &lt;em&gt;Enable the DHCP server&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;On the same wizard, in the &lt;em&gt;User setup&lt;/em&gt; section, I changed the default user setting up a new user and password.&lt;/p&gt;

&lt;p&gt;After this I pressed &lt;em&gt;Apply&lt;/em&gt; to apply the changes and restart the router.&lt;/p&gt;

&lt;p&gt;Once the router has restarted, I disconnected the router from my laptop.&lt;/p&gt;

&lt;p&gt;I connected the eth1 port to a switch serving my home network and rebooted (disconnecting the power cord and connecting it again). After this, the router was accessible on the browser under 192.168.1.140.&lt;/p&gt;

&lt;h3 id=&#34;1-4-dns-configuration&#34;&gt;1.4 DNS configuration&lt;/h3&gt;

&lt;p&gt;Next step is the effective DNS configuration. The idea was to configure a public name server (as Google) and to manually override static some host mappings to have the right DNS resolution from inside the internal network for my applications on the K8s cluster.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In order for the router to find the default gateway, under &lt;em&gt;Routing&lt;/em&gt; I added a new static route with description &lt;em&gt;internetbox&lt;/em&gt;, destination 0.0.0.0 / 0, next hop 192.168.1.1 (which is the IP of the internet box) and interface &lt;em&gt;switch0&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the &lt;em&gt;Config Tree&lt;/em&gt; under &lt;em&gt;system&lt;/em&gt; there is a &lt;em&gt;System parameters&lt;/em&gt; section. There I set up the the &lt;em&gt;name-server&lt;/em&gt; to 127.0.0.1. With this the router will now act as the name server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Under &lt;em&gt;service&lt;/em&gt;, &lt;em&gt;dns&lt;/em&gt; and &lt;em&gt;forwarding&lt;/em&gt;, I configured &lt;em&gt;listen-on&lt;/em&gt; as &lt;em&gt;switch0&lt;/em&gt; and as name-servers 8.8.8.8 and 8.8.8.4 (the Google ones).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The EdgeOS was now ready to act as the DNS server for the home network.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: regarding step 1, another way to do the same is to configure the default gateway in the system configuration.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-4-add-static-host-mapping&#34;&gt;1.4 Add static host mapping&lt;/h3&gt;

&lt;p&gt;The whole point of setting up the own DNS server is to be able to add some static host mappings for IP resolution inside of the network.&lt;/p&gt;

&lt;p&gt;Under &lt;em&gt;Config Tree&lt;/em&gt; and &lt;em&gt;system&lt;/em&gt; I found the &lt;em&gt;static-host-mapping&lt;/em&gt; section. Under &lt;em&gt;host-name&lt;/em&gt; I configured the hostname and the aliases I needed for the application:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hostname:&lt;/strong&gt; &lt;em&gt;cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP:&lt;/strong&gt; 192.168.1.131&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aliases:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;home.cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;drive.cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;photos.cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;settings.cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;store.cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;mailhog.cozy.example.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The IP is the one of the worker&amp;rsquo;s node on the K8s cluster. The hostnames and aliases are the ones needed by the first application I was intending to deploy in K8s:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://eramons.github.io/techblog/post/kubernetes_cluster/&#34; target=&#34;_blank&#34;&gt;Home-made K8s cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eramons.github.io/techblog/post/cozy/&#34; target=&#34;_blank&#34;&gt;Self-Hosted cozy on K8s&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-internet-box&#34;&gt;2. Internet Box&lt;/h2&gt;

&lt;h3 id=&#34;2-1-dns-server-configuration&#34;&gt;2.1. DNS Server Configuration&lt;/h3&gt;

&lt;p&gt;After I had my DNS server up und running, the remaining thing to do was to change the DNS server configuration on the internet box to feature the DNS server I just set up on the EdgeRouter. In the network settings configuration, I just had to change from &lt;em&gt;automatic&lt;/em&gt; to &lt;em&gt;manual&lt;/em&gt; and configure the IP of the router, which was 192.168.1.140.&lt;/p&gt;

&lt;p&gt;I also added a static lease so the router would always get the same IP address.&lt;/p&gt;

&lt;h3 id=&#34;2-2-dyndns&#34;&gt;2.2. DynDNS&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t have a fix IP. I still needed a FQDN.&lt;/p&gt;

&lt;p&gt;The bright side of having to keep the provider&amp;rsquo;s box is that it comes with a DynDNS server working out of the box, so you don&amp;rsquo;t need to register a dedicated account for this. So I activated the feature and I got following hostname: &lt;em&gt;example.myproviderbox.country&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-3-port-forwarding-and-firewall&#34;&gt;2.3. Port Forwarding and Firewall&lt;/h3&gt;

&lt;p&gt;To make the application accessible from the internet, I had to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modify the default firewall configuration to allow inbound traffic to port 443&lt;/li&gt;
&lt;li&gt;Create a port forwarding rule to forward all requests to port 443 to the internal IP address 192.168.1.131 (which was the address of the worker node where nginx was running).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-cloudfare&#34;&gt;3. Cloudfare&lt;/h2&gt;

&lt;p&gt;I have a Cloudfare account and a registered domain. In cloudfare, I set up an alias by adding a CNAME DNS entry, pointing to the internet name I got from the DynDNS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CNAME	example.com	example.myproviderbox.country
CNAME	*.example.com	example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other thing I needed from Cloudfare was an API token for DNS01 challenge resolution for Let&amp;rsquo;s Encrypt.&lt;/p&gt;

&lt;p&gt;Tokens can be created under &lt;em&gt;User Profile&lt;/em&gt; &amp;gt; &lt;em&gt;API Tokens&lt;/em&gt; &amp;gt; &lt;em&gt;API Tokens&lt;/em&gt;. I used the recommended settings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Permissions:
        Zone - DNS - Edit
        Zone - Zone - Read
    Zone Resources:
        Include - All Zones
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these preparations, my home network was ready to host and route requests to applications deployed on the K8s cluster.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links:&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://dl.ubnt.com/guides/edgemax/EdgeRouter_ER-X-SFP_QSG.pdf&#34; target=&#34;_blank&#34;&gt;EdgeRouter X&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cert-manager.io/docs/configuration/acme/dns01/cloudflare&#34; target=&#34;_blank&#34;&gt;Cloudflare&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Home-made K8s Cluster</title>
      <link>https://eramons.github.io/techblog/post/kubernetes_cluster/</link>
      <pubDate>Sat, 21 Mar 2020 15:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/kubernetes_cluster/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Set up a home Kubernetes cluster with old hardware: 1 Master and 1 Worker&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find old hardware&lt;/li&gt;
&lt;li&gt;Install Ubuntu Server 18.04 LTS&lt;/li&gt;
&lt;li&gt;Set up Master Node&lt;/li&gt;
&lt;li&gt;Set up Worker Node&lt;/li&gt;
&lt;li&gt;Service Account&lt;/li&gt;
&lt;li&gt;Install helm&lt;/li&gt;
&lt;li&gt;Install ingress&lt;/li&gt;
&lt;li&gt;Install cert-manager&lt;/li&gt;
&lt;li&gt;Cluster Issuer (Let&amp;rsquo;s Encrypt)&lt;/li&gt;
&lt;li&gt;Storage&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-find-old-hardware&#34;&gt;1. Find old hardware&lt;/h2&gt;

&lt;p&gt;Since kubernetes is lightweight and can run almost everywhere, I decided to go down to the cellar and rescue some old PC which I thought could still work for this. That&amp;rsquo;s what I found:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A MAC Mini Server from year 2009. Two 500GB disks. A still working grub bootloader told me I had a MacOS, an Ubuntu and two Debian distributions installed on the machine. This computer had 4GB RAM. I removed one of the disks, which was broken. One 500GB disk is more than enough for the Master anyway.&lt;/li&gt;
&lt;li&gt;A PC tower whose components were bought separately and which I proudly assembled myself in 2007. Refurbished through the years, this PC had 6GB RAM and three hard disks: 250GB, 500GB and 2TB. Over the two first disks I had a LVM system installed, with a Debian installation and two separated home partitions. The PC didn&amp;rsquo;t boot anymore, since the first disk - hosting the Master Boot Record - was broken. I removed the broken disk and the second LVM disk, keeping only the 2TB disk on the machine.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So I thought the MAC Mini should be my Master and the PC Tower should be my Worker :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://eramons.github.io/techblog/techblog/img/kubehomecluster.jpg&#34; alt=&#34;Home Kubernetes Cluster&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-install-ubuntu-server-lts&#34;&gt;2. Install Ubuntu Server LTS&lt;/h2&gt;

&lt;p&gt;I decided to install the newest Ubuntu Server version with Long Term Support (LTS) on both machines. An alternative could have been to install the latest Debian stable.&lt;/p&gt;

&lt;p&gt;Download Ubuntu Server 18.04.4 LTS from &lt;a href=&#34;https://ubuntu.com/download/server&#34; target=&#34;_blank&#34;&gt;https://ubuntu.com/download/server&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For the MacMini, I just created a bootable USB.&lt;/p&gt;

&lt;p&gt;Insert an USB drive and find out which device is it mapped to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dmesg |grep sd
...
[24400.755280] sd 4:0:0:0: [sdb] Attached SCSI disk
[24406.001628] EXT4-fs (sdb1): mounted filesystem with ordered data mode. Opts: (null)
[39200.249434] sd 4:0:0:0: [sdb] 31266816 512-byte logical blocks: (16.0 GB/14.9 GiB)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It was /dev/sdb. So I copied the downloaded image to the USB drive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=ubuntu-18.04.4-live-server-amd64.iso of=/dev/sdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the old PC, I had to burn a DVD, since it was so old it did not even boot from USB. For that I borrowed a quite old Windows laptop which still had a DVD-drive. I burned the ISO image using the Windows Disc Image Burner.&lt;/p&gt;

&lt;p&gt;After having the media prepared, I installed Ubuntu Server on both machines. In both cases, I chose &amp;ldquo;Manual&amp;rdquo; for setting up the disks and the partitions, using the whole disk.&lt;/p&gt;

&lt;p&gt;NOTE: swap is not supported. Either it must be omitted during installation, or it must be switched off afterwards:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo swapoff -a 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-master-node&#34;&gt;3. Master node&lt;/h2&gt;

&lt;h3 id=&#34;3-1-install-runtime&#34;&gt;3.1. Install runtime&lt;/h3&gt;

&lt;p&gt;I searched for a suitable container runtime to install, gettin two results which made sense for me:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/techblog$ apt-cache search docker.io
containerd - open and reliable container runtime
docker.io - Linux container runtime
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although containerd would be enough, I installed docker.io since having the extra docker tools for debugging or whatever might be useful later:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install docker.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-install-kubernetes-software&#34;&gt;3.2. Install kubernetes software&lt;/h3&gt;

&lt;p&gt;Install kubeadm, kubectl and kubelet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install -y apt-transport-https curl

curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
sudo vi /etc/apt/sources.list.d/kubernetes.list
Add:
deb https://apt.kubernetes.io/ kubernetes-xenial main (probably not good, I have bionic) There is no kubernetes-bionic under packages.cloud.google.com/apt/dists
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kubelet, kubeadm and kubectl are set on hold (to avoid automatic updates, I think)&lt;/p&gt;

&lt;p&gt;After installation, restarting kubelet is required;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl daemon-reload
sudo systemctl restart kubelet
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-initialise-master-node&#34;&gt;3.3 Initialise master node&lt;/h3&gt;

&lt;p&gt;The goal was to set up a single control-plane cluster with kubeadm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo kubeadm init --pod-network-cidr=10.244.0.0/16
...

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &amp;quot;kubectl apply -f [podnetwork].yaml&amp;quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.1.129:6443 --token jn333p.q9hskm01cs12iak7 \
    --discovery-token-ca-cert-hash sha256:0966963ed31ac9d898e3d49d154e2f6ed78931f356af5d6c35616ee75585c2f9

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make kubectl work for your non-root user, run these commands, which are also part of the kubeadm init output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ sudo mkdir -p $HOME/.kube
eramon@pacharan:~$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
eramon@pacharan:~$ sudo chown eramon:eramon .kube/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After these steps, looking at the output of kubectl cluster-info we see kubectl is interacting with our new cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ kubectl cluster-info
Kubernetes master is running at https://192.168.1.129:6443
KubeDNS is running at https://192.168.1.129:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-install-a-pod-network-add-on&#34;&gt;3.4 Install a Pod network add-on&lt;/h3&gt;

&lt;p&gt;As the output of kubeadm said, we must deploy a pod network to the cluster, so the pods can communicate with each other.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
podsecuritypolicy.policy/psp.flannel.unprivileged created
clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.apps/kube-flannel-ds-amd64 created
daemonset.apps/kube-flannel-ds-arm64 created
daemonset.apps/kube-flannel-ds-arm created
daemonset.apps/kube-flannel-ds-ppc64le created
daemonset.apps/kube-flannel-ds-s390x created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show all pods from all namespaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ kubectl get pods --all-namespaces
NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE
kube-system   coredns-6955765f44-597bj           1/1     Running   0          160m
kube-system   coredns-6955765f44-ctwvs           1/1     Running   0          160m
kube-system   etcd-pacharan                      1/1     Running   0          160m
kube-system   kube-apiserver-pacharan            1/1     Running   0          160m
kube-system   kube-controller-manager-pacharan   1/1     Running   0          160m
kube-system   kube-flannel-ds-amd64-dhc7f        1/1     Running   0          62s
kube-system   kube-proxy-qcv98                   1/1     Running   0          160m
kube-system   kube-scheduler-pacharan            1/1     Running   0          160m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flannel was there.&lt;/p&gt;

&lt;h2 id=&#34;4-worker-node&#34;&gt;4. Worker node&lt;/h2&gt;

&lt;h3 id=&#34;4-1-installation&#34;&gt;4.1 Installation&lt;/h3&gt;

&lt;p&gt;I followed exactly the same process described in 3.1 and 3.2 to install the container runtime and the kubernetes software on the worker node.&lt;/p&gt;

&lt;h3 id=&#34;4-2-join-the-cluster&#34;&gt;4.2 Join the cluster&lt;/h3&gt;

&lt;p&gt;First enable docker.service (otherwise kubeadm join shows a warning):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@whisky:~$ sudo systemctl enable docker.service
Created symlink /etc/systemd/system/multi-user.target.wants/docker.service â†’ /lib/systemd/system/docker.service.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since more than 24 hours elapsed between the kubeadm init and the join command, I created a new token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ kubeadm token create
W0321 15:00:44.641034   18998 validation.go:28] Cannot validate kube-proxy config - no validator is available
W0321 15:00:44.641111   18998 validation.go:28] Cannot validate kubelet config - no validator is available
qon04q.9lwkz7i4pixr46q6
eramon@pacharan:~$ kubeadm token list
TOKEN                     TTL         EXPIRES                USAGES                   DESCRIPTION                                                EXTRA GROUPS
qon04q.9lwkz7i4pixr46q6   23h         2020-03-22T15:00:44Z   authentication,signing   &amp;lt;none&amp;gt;                                                     system:bootstrappers:kubeadm:default-node-token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Join worker node by running the following as root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@whisky:/home/eramon# kubeadm join 192.168.1.129:6443 --token qon04q.9lwkz7i4pixr46q6 --discovery-token-ca-cert-hash sha256:0966963ed31ac9d898e3d49d154e2f6ed78931f356af5d6c35616ee75585c2f9
W0321 15:03:52.406236   29903 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.
[preflight] Running pre-flight checks
        [WARNING IsDockerSystemdCheck]: detected &amp;quot;cgroupfs&amp;quot; as the Docker cgroup driver. The recommended driver is &amp;quot;systemd&amp;quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39;
[kubelet-start] Downloading configuration for the kubelet from the &amp;quot;kubelet-config-1.17&amp;quot; ConfigMap in the kube-system namespace
[kubelet-start] Writing kubelet configuration to file &amp;quot;/var/lib/kubelet/config.yaml&amp;quot;
[kubelet-start] Writing kubelet environment file with flags to file &amp;quot;/var/lib/kubelet/kubeadm-flags.env&amp;quot;
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run &#39;kubectl get nodes&#39; on the control-plane to see this node join the cluster.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As instructed by the output of the last command, we take a look at the nodes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ kubectl get nodes
NAME       STATUS   ROLES    AGE     VERSION
pacharan   Ready    master   3d3h    v1.17.4
whisky     Ready    &amp;lt;none&amp;gt;   6m15s   v1.17.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-service-account&#34;&gt;5. Service Account&lt;/h2&gt;

&lt;p&gt;To interact with the Kubernetes cluster from a client machine, for now we&amp;rsquo;ll use the default service account token.&lt;/p&gt;

&lt;p&gt;Service accounts are users managed by the Kubernetes cluster and tied to a set of credentials stored as Secrets, which are mounted into pods allowing in-cluster processes to talk to the Kubernetes API.&lt;/p&gt;

&lt;h3 id=&#34;5-1-install-kubectl&#34;&gt;5.1. Install kubectl&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;On the client machine&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Download binary and install kubectl on the client machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 41.4M  100 41.4M    0     0  5681k      0  0:00:07  0:00:07 --:--:-- 5877k

eramon@caipirinha:~/dev/kubernetes$ chmod +x kubectl 

eramon@caipirinha:~/dev/kubernetes$ sudo mv kubectl /usr/local/bin/kubectl

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-2-grant-access-to-the-cluster-api-for-the-client-machine&#34;&gt;5.2. Grant access to the cluster API for the client machine&lt;/h3&gt;

&lt;p&gt;I just copied the kube configuration from the Master node to my laptop.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: Not sure if this is exactly best practice.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The file is located here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ ls -la /home/eramon/.kube/config 
-rw------- 1 eramon eramon 5449 Mar 18 14:42 /home/eramon/.kube/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After copying the file to the same location on the client machine, I saw my laptop had access to the Kubernetes API on the server via kubectl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~$ kubectl cluster-info
Kubernetes master is running at https://192.168.1.129:6443
KubeDNS is running at https://192.168.1.129:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-install-helm&#34;&gt;6. Install helm&lt;/h2&gt;

&lt;p&gt;Helm is a tool for managing Kubernetes packages called &lt;em&gt;charts&lt;/em&gt;. The chart is a bundle of information necessary to create an instance of a Kubernetes application.&lt;/p&gt;

&lt;p&gt;Downloaded latest helm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/helm$ wget https://get.helm.sh/helm-v3.1.2-linux-amd64.tar.gz
--2020-03-22 13:12:45--  https://get.helm.sh/helm-v3.1.2-linux-amd64.tar.gz
Resolving get.helm.sh (get.helm.sh)... 2606:2800:233:1cb7:261b:1f9c:2074:3c, 152.199.21.175
Connecting to get.helm.sh (get.helm.sh)|2606:2800:233:1cb7:261b:1f9c:2074:3c|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 12269190 (12M) [application/x-tar]
Saving to: â€˜helm-v3.1.2-linux-amd64.tar.gzâ€™

helm-v3.1.2-linux-amd64. 100%[==================================&amp;gt;]  11.70M  2.53MB/s    in 4.6s

2020-03-22 13:12:51 (2.53 MB/s) - â€˜helm-v3.1.2-linux-amd64.tar.gzâ€™ saved [12269190/12269190]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unzip it and instal binary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/helm$ tar -zxvf helm-v3.1.2-linux-amd64.tar.gz
linux-amd64/
linux-amd64/helm
linux-amd64/README.md
linux-amd64/LICENSE

eramon@caipirinha:~/dev/helm$ sudo mv linux-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invoke helm to make sure it&amp;rsquo;s working:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~$ helm version
version.BuildInfo{Version:&amp;quot;v3.1.2&amp;quot;, GitCommit:&amp;quot;d878d4d45863e42fd5cff6743294a11d28a9abce&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;, GoVersion:&amp;quot;go1.13.8&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once Helm is ready, add the official &amp;ldquo;Helm stable charts&amp;rdquo; chart repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~$ helm repo add stable https://kubernetes-charts.storage.googleapis.com/
&amp;quot;stable&amp;quot; has been added to your repositories
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-install-nginx-ingress&#34;&gt;7 Install nginx ingress&lt;/h2&gt;

&lt;p&gt;My cluster needed an ingress controller in order to listen and serve connection requests.&lt;/p&gt;

&lt;p&gt;Since I&amp;rsquo;m working with a home-made cluster installed directly on physical machines running on my home network, the default nginx-ingress configuration won&amp;rsquo;t work for me. On a home configuration there is no load balancer on-demand as with a cloud provider.&lt;/p&gt;

&lt;p&gt;Taking a &amp;ldquo;bare-metal&amp;rsquo; cluster configuration as a reference, this is the setup for my ingress controller:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;kind=DaemonSet&lt;/em&gt;: deploy the ingress controler on every node&lt;/li&gt;
&lt;li&gt;&lt;em&gt;hostNetwork=true&lt;/em&gt;: the nginx daemonset runs on the host namespace&lt;/li&gt;
&lt;li&gt;&lt;em&gt;service.enabled=false&lt;/em&gt;: no service will be created, since we are using DaemonSet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;admisionWebhooks.enabled=false&lt;/em&gt;: we don&amp;rsquo;t want to have ingress admission webhooks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Install nginx-ingress using helm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;helm install mynginx1 stable/nginx-ingress \
	--set controller.admisionWebhooks.enabled=false \
	--set controller.service.enabled=false \
	--set controller.hostNetwork=true \
        --set controller.kind=DaemonSet
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-install-cert-manager&#34;&gt;8 Install cert-manager&lt;/h2&gt;

&lt;p&gt;The issuance, renewal and configuration of TLS server certificates for web applications deployed in the cluster can be automated with Let&amp;rsquo;s Encrypt and cert-manager.&lt;/p&gt;

&lt;p&gt;Install cert-manager from manifest (rather as using helm):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/kubernetes$ kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.14.3/cert-manager.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cert-manager is installed in an own new namespace called &lt;em&gt;cert-manager&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;To make sure cert-manager was installed correctly, list the pods on the namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/techblog$ kubectl get pods -n cert-manager
NAME                                      READY   STATUS    RESTARTS   AGE
cert-manager-77fcb5c94-dfgjm              1/1     Running   0          58m
cert-manager-cainjector-8fff85c75-nmmhn   1/1     Running   0          58m
cert-manager-webhook-54647cbd5-w4fkr      1/1     Running   0          58m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the cert-manager, the cainjector and the webhook are up and running, we should be good.&lt;/p&gt;

&lt;h2 id=&#34;9-clusterissuer&#34;&gt;9 ClusterIssuer&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Issuers&lt;/strong&gt; (and &lt;strong&gt;ClusterIssuers&lt;/strong&gt;) represent a certificate authority from which signed x509 certificates can be obtained. A ClusterIssuer is necessary to issue certificates with cert-manager and Let&amp;rsquo;s Encrypt.&lt;/p&gt;

&lt;p&gt;I used a DNS01 challenge with an api token provided by Cloudflare.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: A DNS01 solver with acme version 2 is mandatory for issuance of wildcard certificates.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ClusterIssuer: &lt;a href=&#34;https://github.com/eramons/kubecozy/blob/master/letsencrypt-prod.yaml.example&#34; target=&#34;_blank&#34;&gt;letsencrypt-prod.yaml.example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;10-storage&#34;&gt;10 Storage&lt;/h2&gt;

&lt;p&gt;There are many different kinds of persistent volumes for K8s. One of them is a NFS server.&lt;/p&gt;

&lt;h3 id=&#34;10-1-set-up-a-nfs-share&#34;&gt;10.1 Set up a NFS share&lt;/h3&gt;

&lt;p&gt;Setting up the NFS share on the Synology NAS was quite straightforward.&lt;/p&gt;

&lt;h3 id=&#34;10-2-install-nfs-common&#34;&gt;10.2 Install nfs-common&lt;/h3&gt;

&lt;p&gt;I installed nfs-common on my worker node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install nfs-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, the worker will be able to nfs-mount folders on my NAS as persistent volumes for the pods.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: not sure if this is best practice. I guess for productive setups required software is installed on each node automatically.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;10-3-persistent-volume&#34;&gt;10.3 Persistent Volume&lt;/h3&gt;

&lt;p&gt;After the NFS share was available on my NAS, I wrote manifests for persistent nfs volumes. I created a dedicated persistent volume for each application.&lt;/p&gt;

&lt;p&gt;The manifest reference the hostname or IP of the NFS server and the path to the share:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: synology-nfs
spec:
  capacity:
    storage: 10Gi
  storageClassName: standard
  accessModes:
  - ReadWriteMany
  nfs:
    server: myServerIP
    path: /path/to/share
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After all these preparations, my new cluster was ready for its first deployment :)&lt;/p&gt;

&lt;h2 id=&#34;appendix-open-points&#34;&gt;Appendix. Open points:&lt;/h2&gt;

&lt;h3 id=&#34;warning&#34;&gt;Warning&lt;/h3&gt;

&lt;p&gt;In both master and worker, I get this warning:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[WARNING IsDockerSystemdCheck]: detected &amp;quot;cgroupfs&amp;quot; as the Docker cgroup driver. The recommended driver is &amp;quot;systemd&amp;quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;warning-1&#34;&gt;Warning&lt;/h3&gt;

&lt;p&gt;When running kubeadm init and when creating a new token, I got warnings on the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@pacharan:~$ kubeadm token create
W0321 15:16:13.144929   25354 validation.go:28] Cannot validate kube-proxy config - no validator is available
W0321 15:16:13.145003   25354 validation.go:28] Cannot validate kubelet config - no validator is available
4w2xrh.i1phnkxkzz7ja5fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references-and-useful-or-interesting-links&#34;&gt;References and useful or interesting links:&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm&#34; target=&#34;_blank&#34;&gt;Install kubeadm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/&#34; target=&#34;_blank&#34;&gt;Install and Set Up kubectl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm&#34; target=&#34;_blank&#34;&gt;Create single-control node cluster with kubeadm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network&#34; target=&#34;_blank&#34;&gt;Install pod network&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coreos/flannel&#34; target=&#34;_blank&#34;&gt;Flannel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://helm.sh/docs/intro/&#34; target=&#34;_blank&#34;&gt;Introduction to Helm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/helm/helm/releases&#34; target=&#34;_blank&#34;&gt;Helm Releases @Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34;&gt;nginx-ingress&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/nginx-ingress&#34; target=&#34;_blank&#34;&gt;nginx helm chart&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cert-manager.io/docs/installation/kubernetes&#34; target=&#34;_blank&#34;&gt;cert-manager&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cert-manager.io/docs/configuration/acme/dns01/cloudflare&#34; target=&#34;_blank&#34;&gt;Cloudflare DNS01 solver&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EHCI Debug</title>
      <link>https://eramons.github.io/techblog/post/debug_coreboot/</link>
      <pubDate>Wed, 13 Mar 2019 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/debug_coreboot/</guid>
      <description>

&lt;p&gt;The EHCI Debug Port is an optional capability of EHCI controllers which can be used for early debugging for hardware which does not have a serial port. All USB2 host controllers are EHCI controllers.&lt;/p&gt;

&lt;p&gt;Since I installed Coreboot on my Librem, I experienced some issues. In order to investigate - and since the Librem has no serial port - I aimed to do some Coreboot and kernel debugging with a Raspberry Pi Zero.&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Edit the kernel configuration to include the print ehci and xhci output options.&lt;/li&gt;
&lt;li&gt;Activate USB Debug output on Coreboot&lt;/li&gt;
&lt;li&gt;Set up a Raspberry Pi Zero to use it as EHCI client (USB Gadget).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-custom-debian-kernel-on-librem-13v1&#34;&gt;1. Custom Debian Kernel on Librem 13v1&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: enable USB (EHCI) kernel debug output.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We need a self-built Debian kernel where EHCI is enabled in the kernel configuration.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;On the Librem&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First find out the version of the installed kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~$ uname -a
Linux caipirinha 4.19.0-2-amd64 #1 SMP Debian 4.19.16-1 (2019-01-17) x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download and unpack debian kernel source:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install linux-source-4.19
tar xaf /usr/src/linux-source-4.19.tar.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install kernel build dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt build-dep linux-image-4.19.0-2-amd64
linux-image-amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get current configuration and generate defaults for missing properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd linux-source-4.19
cp /boot/config-4.19.0-2-amd64 .config
make olddefconfig 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run makemenuconfig and activate the kernel config option for EHCI Debug (by default not enabled on the Debian kernel):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig

&amp;gt; Search (CONFIG_EARLY_PRINTK_DBGP) &amp;gt; Early printk
	--- Early printk
	[*] Early printk via EHCI debug port
	...
	[*] Earl printk via the xHCI debug port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save &amp;amp; Exit.&lt;/p&gt;

&lt;p&gt;When first trying to build the kernel, I got a certificate error. Researching a little I found a thread explaining the problem and the solution (see references). In the .config file copied from /boot, I had to find and comment out following properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG_SYSTEM_TRUSTED_KEYS
CONFIG_MODULE_SIG_ALL
CONFIG_MODULE_SIG_KEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this way the custom kernel will be able to get modules signed by a one-time key.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: is there eventually a better way to get the .config so we can avoid the certificate issue?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Invoking make afterwards prompted me to configure some kernel options related to the ones I edited before. I chose the defaults in all cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/debian/linux-source-4.19$ make deb-pkg -j8
scripts/kconfig/conf  --syncconfig Kconfig
*
* Restart config...
*
*
* Certificates for signature checking
*
File name or PKCS#11 URI of module signing key (MODULE_SIG_KEY) [certs/signing_key.pem] (NEW) 
Provide system-wide ring of trusted keys (SYSTEM_TRUSTED_KEYRING) [Y/?] y
  Additional X.509 keys for default system keyring (SYSTEM_TRUSTED_KEYS) [] (NEW) 
  Reserve area for inserting a certificate without recompiling (SYSTEM_EXTRA_CERTIFICATE) [N/y/?] n
  Provide a keyring to which extra trustable keys may be added (SECONDARY_TRUSTED_KEYRING) [N/y/?] n
Provide system-wide ring of blacklisted keys (SYSTEM_BLACKLIST_KEYRING) [N/y/?] n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The kernel built succeeded and following .deb files were generated by the build process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
eramon@caipirinha:~/debian$ ls -la linux-image*deb
-rw-r--r-- 1 eramon eramon  46189016 Mar 25 22:25 linux-image-4.19.16_4.19.16-1_amd64.deb
-rw-r--r-- 1 eramon eramon 669497020 Mar 25 22:43 linux-image-4.19.16-dbg_4.19.16-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the new kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg -i linux-image-4.19.16_4.19.16-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the installation, following files have been installed under /boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/debian$ ls -la /boot |grep 4.19.16
-rw-r--r--  1 root root   206398 Mar 25 21:06 config-4.19.16
-rw-r--r--  1 root root 32961834 Mar 26 07:43 initrd.img-4.19.16
-rw-r--r--  1 root root  3346540 Mar 25 21:06 System.map-4.19.16
-rw-r--r--  1 root root  5187456 Mar 25 21:06 vmlinuz-4.19.16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the kernel should print both ehci and xhci output, which we can see using a USB gadget - for example the Raspberry Pi Zero. Keep reading to find out more.&lt;/p&gt;

&lt;h2 id=&#34;2-coreboot-configuration&#34;&gt;2. Coreboot Configuration&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: activate USB Debug Output in the Coreboot configuration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Find the USB debug port:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lshw
...
        *-usb:1
             description: USB controller
             product: Wildcat Point-LP USB EHCI Controller
             vendor: Intel Corporation
             physical id: 1d
             bus info: pci@0000:00:1d.0
             version: 03
             width: 32 bits
             clock: 33MHz
             capabilities: pm debug ehci bus_master cap_list
             configuration: driver=ehci-pci latency=0
             resources: irq:23 memory:b221a000-b221a3ff
           *-usbhost
                product: EHCI Host Controller
                vendor: Linux 4.19.16 ehci_hcd
                physical id: 1
                bus info: usb@1
                logical name: usb1
                version: 4.19
                capabilities: usb-2.00
                configuration: driver=hub slots=2 speed=480Mbit/s
              *-usb
                   description: USB hub
                   vendor: Intel Corp.
                   physical id: 1
                   bus info: usb@1:1
                   version: 0.03
                   capabilities: usb-2.00
                   configuration: driver=hub slots=8 speed=480Mbit/s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get a USB debug console, enable both CONFIG_USBDEBUG and CONFIG_CONSOLE_USB (menu option USB 2.0 EHCI debug dongle support) in coreboot&amp;rsquo;s kconfig.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /home/eramon/dev/coreboot-working/.config - coreboot configuration
 &amp;gt; Debugging &amp;gt; Search (CONFIG_USBDEBUG)

Symbol: USBDEBUG [=y]                                                                                                                                                                                      â”‚  
  â”‚ Type  : boolean                                                                                                                                                                                            â”‚  
  â”‚ Prompt: USB 2.0 EHCI debug dongle support                                                                                                                                                                  â”‚  
  â”‚   Location:                                                                                                                                                                                                â”‚  
  â”‚ (1) -&amp;gt; Generic Drivers                                                                                                                                                                                     â”‚  
  â”‚   Defined at src/mainboard/msi/ms9652_fam10/Kconfig:63                                                                                                                                                     â”‚  
  â”‚   Depends on: VENDOR_MSI [=n] &amp;amp;&amp;amp; BOARD_MSI_MS9652_FAM10 [=n] 


/home/eramon/dev/coreboot-working/.config - coreboot configuration
 &amp;gt; Debugging &amp;gt; Search (CONFIG_USBDEBUG) &amp;gt; Generic Drivers

 [*] USB 2.0 EHCI debug dongle support
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-set-up-raspberry-pi-zero&#34;&gt;3. Set up Raspberry Pi Zero&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: set up a Raspberry Pi Zero as USB Device (a.k.a USB Gadget)&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-1-customize-raspbian&#34;&gt;3.1. Customize Raspbian&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;On any computer running Linux&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Insert a sdcard.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Download latest Raspbian image (see references for Downloads link).&lt;/p&gt;

&lt;p&gt;Unzip and copy the image to the sdcard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unzip 2018-11-13-raspbian-stretch-lite.zip
sudo dd if=2018-11-13-raspbian-stretch-lite.img of=/dev/sdb bs=4M conv=fsync
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Extract the sdcard and insert it again.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Two new drives should be automatically mounted: boot and rootfs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/techblog$ mount |grep sdb
/dev/sdb1 on /media/eramon/boot type vfat (rw,nosuid,nodev,relatime,uid=1000,gid=1000,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)
/dev/sdb2 on /media/eramon/rootfs type ext4 (rw,nosuid,nodev,relatime,uhelper=udisks2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the boot partition, edit following file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /media/eramon/boot/config.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add these lines at the end, in order to enable serial port output and device tree overlay.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Enable serial
enable_uart=1

# Device tree overlay and DesignWare Core driver
dtoverlay=dwc2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the same partition, enable ssh by creating an empty ssh file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch /media/eramon/boot/ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sync:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Extract the sdcard.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Insert the sdcard on the Raspberry Pi Zero.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Connect a serial/USB debug cable to the corresponding GPIO pins on the board (see references to find out how). Connect the USB end of the cable to the laptop and start minicom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo minicom -D /dev/ttyUSB0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log in via serial. The default username is pi and the password is raspberry.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Raspbian GNU/Linux 9 raspberrypi ttyS0
raspberrypi login: pi
Password: 
Linux raspberrypi 4.14.79+ #1159 Sun Nov 4 17:28:08 GMT 2018 armv6l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;On the Raspberry Pi Zero&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Configure wifi and find out IP address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo raspi-config

2. Network options	Configure network settings
N2 Wi-fi		Enter SSID and passphrase
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~$ ip address                                                   
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: wlan0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether b8:27:eb:d8:e2:69 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.198/24 brd 192.168.81.255 scope global wlan0
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can connect to the board directly via SSH.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: alternatively, instead of connecting via serial (and afterwards via SSH), you can use a mini-HDMI to HDMI adapter for connecting a display to the board.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-2-usb-gadget-kernel-modules&#34;&gt;3.2. USB Gadget Kernel modules&lt;/h3&gt;

&lt;p&gt;In order for the Raspberry Pi to behave as an USB Device, we need to modify the raspbian kernel to include the corresponding modules and to apply some patches.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;On any computer running Linux&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First of all, log in to the raspberry pi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pi@192.168.1.198
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;On the Raspberry Pi Zero&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Update sources and upgrade the system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install kernel build dependencies and get the kernel source:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install git bc libncurses5-dev flex bison libsssl-dev
git clone --depth=1 https://github.com/raspberrypi/linux

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate Raspberry Pi Zero default kernel configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd linux
KERNEL=kernel
make bcmrpi_defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run make menuconfig to activate the module we need:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enable g_dbgp in menuconfig as a module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â€“ Device Drivers -&amp;gt; USB Support -&amp;gt; USB Gadget Support -&amp;gt; EHCI Debug Device Gadget
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build kernel, modules and device tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j4 zImage modules dtbs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download patches to fix known issues (see references below):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://johnlewis.ie/debug_patches.tar.xz
tar -xJf debug_patches.tar.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apply the patches:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~/dev/linux $ patch -p0 &amp;lt; dbgp.patch
patching file drivers/usb/gadget/legacy/dbgp.c
Hunk #1 succeeded at 211 (offset 1 line).
Hunk #2 succeeded at 375 (offset 1 line).
pi@raspberrypi:~/dev/linux $ patch -p0 &amp;lt; gadget.patch
patching file drivers/usb/dwc2/gadget.c
Hunk #1 succeeded at 1687 (offset 504 lines).
pi@raspberrypi:~/dev/linux $ patch -p0 &amp;lt; u_serial.patch
patching file drivers/usb/gadget/function/u_serial.c
Hunk #1 succeeded at 1373 (offset -145 lines).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build and install the kernel, modules and device tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j4 zImage modules dtbs
sudo make modules_install
sudo cp arch/arm/boot/dts/*.dtb /boot/
sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/
sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/
sudo cp arch/arm/boot/zImage /boot/kernel.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;_Note: this commands are extracted from the official Raspberry Pi documentation (kernel build) - see references. What I do not understand: why copy and not just make install?__&lt;/p&gt;

&lt;p&gt;Reboot.&lt;/p&gt;

&lt;p&gt;Run modprobe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo modprobe g_dbgp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if the modules we need are loaded and running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ sudo lsmod |grep dbg
g_dbgp                  2987  0
libcomposite           50203  1 g_dbgp
u_serial               10969  1 g_dbgp
udc_core               39660  4 u_serial,dwc2,libcomposite,g_dbgp

pi@raspberrypi:~ $ sudo lsmod |grep dwc2
dwc2                  156750  0
udc_core               39660  4 u_serial,dwc2,libcomposite,g_dbgp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install minicom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install minicom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect to /dev/ttyGS0 with minicom&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo minicom -D /dev/ttyGS0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now connect the EHCI-enabled device via the micro USB cable and boot it.
With a micro USB/USB cable, connect the EHCI host (the Librem) to the USB Gadget (the Raspberry Pi). Reboot.&lt;/p&gt;

&lt;p&gt;Done. I was able to see the Coreboot output :)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: I should also be able to see the kernel debug output&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: extend Coreboot documentation in order to add the Raspberry Pi Zero as an official supported USB device.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;References and links:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.coreboot.org/EHCI_Debug_Port&#34; target=&#34;_blank&#34;&gt;Coreboot EHCI Debug&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://debian-handbook.info/browse/stable/sect.kernel-compilation.html&#34; target=&#34;_blank&#34;&gt;Debian Handbook Kernel Compilation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.debian.org/debian-kernel/2016/04/msg00579.html&#34; target=&#34;_blank&#34;&gt;Debian Kernel Thread&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://downloads.raspberrypi.org/raspbian_lite_lates&#34; target=&#34;_blank&#34;&gt;Raspbian Downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.raspberrypi.org/documentation/configuration/uart.md&#34; target=&#34;_blank&#34;&gt;Raspberry Pi Uart Configuration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://learn.adafruit.com/raspberry-pi-zero-creation/give-it-life&#34; target=&#34;_blank&#34;&gt;Serial Console Cable Raspberry Pi Zero&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.raspberrypi.org/documentation/linux/kernel/building.md&#34; target=&#34;_blank&#34;&gt;Raspberry Pi Kernel Building&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://johnlewis.ie/pi-zero-w-flashrom-and-usb-gadget-debug&#34; target=&#34;_blank&#34;&gt;Pi Zero W Flashrom and USB Gadget Debug&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build Coreboot</title>
      <link>https://eramons.github.io/techblog/post/build_coreboot/</link>
      <pubDate>Mon, 25 Feb 2019 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/build_coreboot/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;DISCLAIMER: try anything described here at your own risk! These are just my notes. That it did work for me then does not mean this would work for you now.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After successfully installing coreboot on my librem 13 v1, I noticed that unfortunately the wifi wasn&amp;rsquo;t working anymore. Since the coreboot version I flashed previously wasn&amp;rsquo;t quite new, I decided to build a new rom image myself using the newest coreboot source code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Replace coreboot with an up-to-date, self-built coreboot version&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Get required files: coreboot source code, purism config and librem binary blobs&lt;/li&gt;
&lt;li&gt;Configure and build coreboot&lt;/li&gt;
&lt;li&gt;Install coreboot&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-get-the-files&#34;&gt;1. Get the files&lt;/h2&gt;

&lt;p&gt;Get coreboot source code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://review.coreboot.org/coreboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install build dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install -y bison build-essential curl flex git gnat libncurses5-dev m4 zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install flashrom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flashrom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build coreboot toolchain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd coreboot
make crossgcc-i386 CPUS=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pull coreboot submodules, since some are needed in order to build cbfstool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule update --init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build cbfstool and ifdtool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd util/cbfstool
make
cd ../util/ifdtool
make
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since coreboot was already on my laptop, I was able to extract the binary blobs from the machine itself.&lt;/p&gt;

&lt;p&gt;I analyzed purism&amp;rsquo;s coreboot installation script (see references below) in order to find out how to get the binary blobs.&lt;/p&gt;

&lt;p&gt;Create blob directory, following coreboot file structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p 3rdparty/blobs/mainboard/purism/librem_bdw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get the currently installed coreboot image with &lt;em&gt;flashrom&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo flashrom -p internal:laptop=force_I_want_a_brick,ich_spi_mode=hwseq -r coreboot-orig.rom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use &lt;em&gt;ifdtool&lt;/em&gt; to extract the flash regions from the rom image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ./util/ifdtool/ifdtool -x coreboot-orig.rom 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output of &lt;em&gt;idftool&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File coreboot-orig.rom is 8388608 bytes
  Flash Region 0 (Flash Descriptor): 00000000 - 00000fff 
  Flash Region 1 (BIOS): 00200000 - 007fffff 
  Flash Region 2 (Intel ME): 00001000 - 001fffff 
  Flash Region 3 (GbE): 00fff000 - 00000fff (unused)
  Flash Region 4 (Platform Data): 00fff000 - 00000fff (unused)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the file containing the second flash region to &lt;em&gt;me.bin&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp flashregion_2_intel_me.bin 3rdparty/blobs/mainboard/purism/librem_bdw/me.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download &lt;em&gt;cpu_microcode_blob.bin&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget -O 3rdparty/blobs/mainboard/purism/librem_bdw/cpu_microcode_blob.bin &amp;quot;https://github.com/platomav/CPUMicrocodes/raw/18a85ffed180447aa16c2796146ff2698691eddf/Intel/cpu306D4_platC0_ver0000002A_2018-01-18_PRD_CC79BBDA.bin&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extract &lt;em&gt;mrc.bin&lt;/em&gt; from the rom image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;util/cbfstool/cbfstool coreboot-orig.rom extract -n mrc.bin -f 3rdparty/blobs/mainboard/purism/librem_bdw/mrc.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extract &lt;em&gt;refcode.elf&lt;/em&gt; from the rom image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;util/cbfstool/cbfstool coreboot-orig.rom extract -n fallback/refcode -f 3rdparty/blobs/mainboard/purism/librem_bdw/refcode.elf -m x86
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extract &lt;em&gt;vgabios.bin&lt;/em&gt; from the rom image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;util/cbfstool/cbfstool coreboot-orig.rom extract -n pci8086,1616.rom -f 3rdparty/blobs/mainboard/purism/librem_bdw/vgabios.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clone the &lt;em&gt;coreboot-files&lt;/em&gt; from purism&amp;rsquo;s github repository to get &lt;em&gt;descriptor.bin&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://source.puri.sm/coreboot/coreboot-files.git
cp coreboot-files/descriptor-bdl.bin 3rdparty/blobs/mainboard/purism/librem_bdw/descriptor.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m including the output of &lt;em&gt;sha256sum&lt;/em&gt; on all six binaries - which I compared with the ones provided by purism on their script as a security check:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;69537c27d152ada7dce9e35bfa16e3cede81a18428d1011bd3c33ecae7afb467  3rdparty/blobs/mainboard/purism/librem_bdw/cpu_microcode_blob.bin
be34b19b4de387a07d4fc859d2e4ee44723756f5f54552f236136679b4e52c46  3rdparty/blobs/mainboard/purism/librem_bdw/descriptor.bin
1e8f08c3eb31a0fdb91ec0222d4398b9192141502941a5262e9155915ffb6991  3rdparty/blobs/mainboard/purism/librem_bdw/me.bin
dd05ab481e1fe0ce20ade164cf3dbef3c479592801470e6e79faa17624751343  3rdparty/blobs/mainboard/purism/librem_bdw/mrc.bin
8a919ffece61ba21664b1028b0ebbfabcd727d90c1ae2f72b48152b8774323a4  3rdparty/blobs/mainboard/purism/librem_bdw/refcode.elf
e1cd1b4f2bd21e036145856e2d092eb47c27cdb4b717c3b182a18d8c0b1d0f01  3rdparty/blobs/mainboard/purism/librem_bdw/vgabios.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-configure-and-build-coreboot&#34;&gt;2. Configure and build coreboot&lt;/h2&gt;

&lt;p&gt;Copy the &lt;em&gt;.config&lt;/em&gt; file from purism&amp;rsquo;s &lt;em&gt;coreboot-files&lt;/em&gt; downloaded before. Then run &lt;em&gt;make menuconfig&lt;/em&gt; and select &lt;em&gt;save&lt;/em&gt; in order to update the configuration including all settings not yet included:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp coreboot-files/configs/config.librem13v1 .config
make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following file paths must be corrected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-CONFIG_BOOTSPLASH_FILE=&amp;quot;bootsplash.jpg&amp;quot;
+CONFIG_BOOTSPLASH_FILE=&amp;quot;coreboot-files/bootsplash.jpg&amp;quot;

-CONFIG_SEABIOS_BOOTORDER_FILE=&amp;quot;bootorder.txt&amp;quot;
+CONFIG_SEABIOS_BOOTORDER_FILE=&amp;quot;coreboot-files/bootorder-l13v1.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now .config is ready and we can build coreboot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-install-coreboot&#34;&gt;3. Install coreboot&lt;/h2&gt;

&lt;p&gt;Before flashing, reboot including the kernel parameter &lt;em&gt;iomem=relaxed&lt;/em&gt;, otherwise flashrom will fail. For this, press &amp;ldquo;e&amp;rdquo; when the grub menu is shown and edit the kernel command line manually.&lt;/p&gt;

&lt;p&gt;After reboot, I flashed the new image I had just built:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo flashrom -p internal:laptop=force_I_want_a_brick -c MX25L6405D -w build/coreboot.rom 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then a cool reboot - luckily the computer still booted :D&lt;/p&gt;

&lt;p&gt;I saw first the SeeBios message, then the Purism Logo and then the Grub boot menu.&lt;/p&gt;

&lt;p&gt;The wifi wasn&amp;rsquo;t working yet. However, that is another story and shall be told another time ;)&lt;/p&gt;

&lt;p&gt;References and sources:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.coreboot.org/lessons/lesson1.html&#34; target=&#34;_blank&#34;&gt;Coreboot Rookie Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://puri.sm/coreboot&#34; target=&#34;_blank&#34;&gt;https://puri.sm/coreboot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.flashrom.org/FAQ&#34; target=&#34;_blank&#34;&gt;Flashrom FAQ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/techblog/post/coreboot_librem&#34; target=&#34;_blank&#34;&gt;Coreboot on Librem&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Install Coreboot on the Librem 13 v.1</title>
      <link>https://eramons.github.io/techblog/post/coreboot_librem/</link>
      <pubDate>Mon, 18 Feb 2019 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/coreboot_librem/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;DISCLAIMER: try this at your own risk! The information below it&amp;rsquo;s just a summary of my notes and experiences during the installation of coreboot on my notebook.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I am the proud owner of a Librem 13 v1 (bought in September 2016). Currently all librem laptops are shipped with coreboot installed on them, but mine was still shipped with propietary firmware on it. Fortunately coreboot is supported anyway - it was possible for me to install coreboot myself.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Replace the propietary bootloader firmware shipped with the Librem 13 v.1 with coreboot&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Switch from an UEFI install to a BIOS one&lt;/li&gt;
&lt;li&gt;Backup the firmware&lt;/li&gt;
&lt;li&gt;Flash coreboot&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-migrate-to-a-non-uefi-installation&#34;&gt;1. Migrate to a non-UEFI installation&lt;/h2&gt;

&lt;p&gt;The librem supports Coreboot with SeaBios as payload. Tianocore is not supported, so an UEFI installation won&amp;rsquo;t boot after replacing the bootloader.&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check if the debian system installed on the laptop is a UEFI or a BIOS install&lt;/li&gt;
&lt;li&gt;Check if the partition layout is MBR or GPT&lt;/li&gt;
&lt;li&gt;Resize the existing partitions in order to free 100 MB at the beginning of the disk&lt;/li&gt;
&lt;li&gt;Create a new 100 MB partition&lt;/li&gt;
&lt;li&gt;Re-install grub&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When I got my librem 13 on September 2016, I replaced the shipped OS (PureOS) through an UEFI-booted debian system. In order to make sure the OS is indeed installed on UEFI mode, I quickly checked:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There is a /sys/firmware/efi on the rootfs&lt;/li&gt;
&lt;li&gt;There is a fat32 partition (called &amp;ldquo;efi&amp;rdquo;) mounted on /boot/efi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two possible partition schemes exist:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MBR (Master Boot Record): older&lt;/li&gt;
&lt;li&gt;GPT (GUID Partition Table): newer - required to boot operating systems in UEFI mode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s important to know which one is being used. Since the OS installation was an UEFI-mode debian, it was for sure that the disk scheme had to be GPT.&lt;/p&gt;

&lt;p&gt;Anyway, it&amp;rsquo;s possible to check this for example looking at the output of fdisk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sda
	...
Disklabel type: gpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or even better gdisk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gdisk /dev/sda
	...
Partition table scan:
	MBR: protective
	BSD: not present
	APM: not present
	GPT: present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use grub as 2nd stage bootloader. In non-EFI mode, grub is able to boot from a partitioned GPT disk if using a compatible boot scheme, which consists on having a special 100 MB partition at the start of the disk.&lt;/p&gt;

&lt;p&gt;I looked at the partitions on my librem (you can use either gparted or gdisk):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;/dev/sda1 - boot:  ext4 partition mounted on /boot with size=500 MB (113 MB used)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/dev/sda2 - efi: fat32 partition mounted on /boot/efi with size=500 MB and flags &amp;ldquo;boot&amp;rdquo; and &amp;ldquo;esp&amp;rdquo; set&lt;/li&gt;
&lt;li&gt;/dev/sda3 - system: crypt-luks (encrypted) partition&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The boot partition must be resized and moved in order to have a new 100 MB partition at the beginning of the disk. Since the partitions must be unmounted to do that, I created a live debian stretch usb drive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=/home/eramon/Downloads/debian-live-9.8.0-amd64-gnome.iso of=/dev/sdb bs=1M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Reboot to the live system on the usb.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Boot from the USB drive (pressing F2 to enter setup and selecting boot override).&lt;/p&gt;

&lt;p&gt;On the live CD, I used gparted to resize the boot partition, freing 100 MB at the beginning of the disk.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gparted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Reboot to the debian system.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I used gdisk to create the new 100 MB partition for grub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Command (? for help): n
Partition number (4-128, default 4):
First sector (34-976773134, default = 2048) or {+-}size{KMGTP}:
Last sector (2048-206847, default = 206847) or {+-}size{KMGTP}: +100M
Current type is &#39;Linux filesystem&#39;
Hex code or GUID (L to show codes, Enter = 8300): ef02
Changed type of partition to &#39;BIOS boot partition&#39;

Command (? for help): p 
	...
Number  Start (sector)    End (sector)  Size       Code  Name
   1          206848         1023999   399.0 MiB   8300  boot
   2         1024000         2047999   500.0 MiB   EF00  efi
   3         2048000       976771071   464.8 GiB   8300
   4            2048          206847   100.0 MiB   EF02  BIOS boot partition

Command (? for help): wq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify /etc/fstab and comment out the mount of the /boot/efi partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Removed on 2019 February 18th to switch to a non-EFI system to be able to install coreboot:
# UUID=559D-9E15  /boot/efi       vfat    umask=0077      0       1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, I removed grub-efi and installed grub2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg --purge grub-efi
sudo apt-get -f autoremove
sudo apt-get update
sudo apt-get grub2
sudo grub install --target=i386-pc /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The target parameter must be specified, otherwise grub tries to install grub on efi mode.&lt;/li&gt;
&lt;li&gt;Grub must be installed to the disk (/dev/sda) an not to the partition (/dev/sda2 - e.g. the boot partition) as it would be for grub-efi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reboot to see if it worked. To be sure, I went into the bios and tried a boot override. There were two different boot options, both for the same disk. One of them is the UEFI boot and the other is the non-UEFI one. Both worked.&lt;/p&gt;

&lt;h2 id=&#34;2-backup-the-existing-firmware&#34;&gt;2. Backup the existing firmware&lt;/h2&gt;

&lt;p&gt;First install flashrom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flashrom 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flashrom dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install libftdi1 libftdi1-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: the dependencies are installed by the flashrom package. However I used first another flashrom binary, so I had to install the dependencies manually, that&amp;rsquo;s why I&amp;rsquo;m mentioning them here.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Use flashrom to make a backup of the exiting firmware:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flashrom
sudo flashrom -p internal:laptop=force_I_want_a_brick,ich_spi_mode=hwseq -r libremfw_orig.rom  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-install-coreboot&#34;&gt;3. Install Coreboot&lt;/h2&gt;

&lt;p&gt;Purism provides on their website instructions and one script to configure, build and install coreboot on the librem with flashrom (see references). Although I found the information on the site useful, the script didn&amp;rsquo;t work for me. The problem seemed to be that the script needs some binary blobs which should be extracted from the laptop itself, unfortunately this only works if coreboot is already installed on the machine.&lt;/p&gt;

&lt;p&gt;I wrote the purism support, who kindly informed me that the available script was not mantained anymore and who provided me with an image file containing both all necessary binary blobs and coreboot built with the configuration needed by my board:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file coreboot-l13v1.rom 
coreboot-l13v1.rom: Intel serial flash for PCH ROM

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to avoid getting an error during flashing and following the instructions of the flashrom FAQ, I overrided the kernel command line to include iomem=relaxed. In order to do that, press &amp;ldquo;e&amp;rdquo; when the grub menu appears during boot and modify the cmdline manually. Resume boot with F10.&lt;/p&gt;

&lt;p&gt;This is the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enabling flash write... Error accessing ICH RCRB, 0x4000 bytes at 0x00000000fed1c000
/dev/mem mmap failed: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After having booted with a relaxed iomem, I was ready to flash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo flashrom -p internal:laptop=force_I_want_a_brick -w coreboot-l12v1.rom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done :) I rebooted and was greeted by the Purism logo and SeeBios.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: The &amp;ldquo;want a brick&amp;rdquo; option seemed pretty scary to me. Apparently flashrom says the board is not officially supported and enforces the use of this flag to proceed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I include here the flashrom output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@caipirinha:~/dev/coreboot-l13v1-oem$ sudo ./flashrom -p internal:laptop=force_I_want_a_brick -w coreboot-l13v1.rom
flashrom v1.0 on Linux 4.19.0-2-amd64 (x86_64)
flashrom is free software, get the source code at https://flashrom.org

Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns).
========================================================================
WARNING! You seem to be running flashrom on an unsupported laptop.
Laptops, notebooks and netbooks are difficult to support and we
recommend to use the vendor flashing utility. The embedded controller
(EC) in these machines often interacts badly with flashing.
See the manpage and https://flashrom.org/Laptops for details.

If flash is shared with the EC, erase is guaranteed to brick your laptop
and write may brick your laptop.
Read and probe may irritate your EC and cause fan failure, backlight
failure and sudden poweroff.
You have been warned.
========================================================================
Proceeding anyway because user forced us to.
Found chipset &amp;quot;Intel Broadwell U Premium&amp;quot;.
This chipset is marked as untested. If you are using an up-to-date version
of flashrom *and* were (not) able to successfully update your firmware with it,
then please email a report to flashrom@flashrom.org including a verbose (-V) log.
Thank you!
Enabling flash write... Warning: SPI Configuration Lockdown activated.
Enabling hardware sequencing because some important opcode is locked.
OK.
Found Programmer flash chip &amp;quot;Opaque flash chip&amp;quot; (8192 kB, Programmer-specific) mapped at physical address 0x0000000000000000.
Reading old flash chip contents... done.
Erasing and writing flash chip... Erase/write done.
Verifying flash... VERIFIED.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;References and useful or interesting links:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://puri.sm&#34; target=&#34;_blank&#34;&gt;Purism&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/GRUB#GUID_Partition_Table_.28GPT.29_specific_instructions&#34; target=&#34;_blank&#34;&gt;ArchLinux Grub Documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://puri.sm/coreboot&#34; target=&#34;_blank&#34;&gt;https://puri.sm/coreboot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.debian.org/CD/live&#34; target=&#34;_blank&#34;&gt;https://www.debian.org/CD/live&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.flashrom.org/FAQ&#34; target=&#34;_blank&#34;&gt;Flashrom FAQ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian on Asus Chromebook Flip C101PA</title>
      <link>https://eramons.github.io/techblog/post/asuschromebook_debian/</link>
      <pubDate>Tue, 04 Dec 2018 10:00:00 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/asuschromebook_debian/</guid>
      <description>

&lt;p&gt;&lt;em&gt;The Asus Chromebook Flip C101PA (bob) is a convertible touchscreen laptop powered by an ARMv8 Rockchip RK3399 hexa-core processor and 4GB RAM, measuring 10.4&amp;rdquo; x 7.2&amp;rdquo; x 0.6&amp;rdquo; and weighing 1 kg.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rockchip RK3399 (OP1) dual-core 2.0GHz Cortex-A72 and quad-core 1.4GHz Cortex-A53 processor&lt;/li&gt;
&lt;li&gt;4GB LPDDR3 RAM&lt;/li&gt;
&lt;li&gt;10.1&amp;rdquo; 1280x800 LED display&lt;/li&gt;
&lt;li&gt;Mali T860MP4 GPU&lt;/li&gt;
&lt;li&gt;16GB eMMC&lt;/li&gt;
&lt;li&gt;38 Whrs battery&lt;/li&gt;
&lt;li&gt;2x USB 3.1 Type-C ports&lt;/li&gt;
&lt;li&gt;1x USB 2.0 Type-A port&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARM Chromebooks ship with the Coreboot bootloader and use Depthcharge as the payload. Further reading:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.coreboot.org&#34; target=&#34;_blank&#34;&gt;Coreboot Website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coreboot/depthcharge&#34; target=&#34;_blank&#34;&gt;Depthcharge Source Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The kernel is signed and packed in a custom format and must be flashed to a dedicated partition on the sdcard or to the internal ssd. Further reading:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.chromium.org/chromium-os/chromiumos-design-docs/disk-format&#34; target=&#34;_blank&#34;&gt;Chromium: Disk Format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;After enabling Developer Mode and USB Boot, it&amp;rsquo;s possible to boot either ChromeOS from the internal disk of the chromebook (Ctrl-D) or from USB (Ctrl-U).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Goal: run Debian on the ChromeOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Motivation:&lt;/strong&gt; the Asus C101PA is a light (and cheap) laptop - perfect to carry it everywhere. Using ChromeOS only was not an option for me, so I aimed to run Debian Linux on it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Milestones:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Dual boot ChromeOS and Linux: run archlinux on a sdcard&lt;/li&gt;
&lt;li&gt;Replace the archlinux filesystem with a Debian rootfs&lt;/li&gt;
&lt;li&gt;Replace the kernel (ChromeOS) with the mainline Linux kernel&lt;/li&gt;
&lt;li&gt;Troubleshooting: modify kernel options and install firmware&lt;/li&gt;
&lt;li&gt;Flash the working kernel to the chromebook internal memory&lt;/li&gt;
&lt;li&gt;Replace the kernel (Linux) with the latest Debian kernel&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Files and scripts available in github:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/chromebook&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-archlinux&#34;&gt;1. Archlinux&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: try out a working linux distribution on the Chromebook&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;On the chromebook&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I started taking a look at the excelent Arch Linux wiki:
&lt;a href=&#34;https://archlinuxarm.org/platforms/armv8/rockchip/asus-chromebook-flip-c101pa&#34; target=&#34;_blank&#34;&gt;ArchLinuxArm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This links provides instructions for the installation of Arch Linux from a sdcard in dual boot setup. I closely followed the instructions in order to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Enable Developer Mode&lt;/li&gt;
&lt;li&gt;Enable booting from USB&lt;/li&gt;
&lt;li&gt;Partition the sdcard&lt;/li&gt;
&lt;li&gt;Download the tarball. The Arch Linux tarball includes the ChromeOS kernel and an Arch Linux filesystem.&lt;/li&gt;
&lt;li&gt;Copy the file system to the second partition on the card&lt;/li&gt;
&lt;li&gt;Flash the kernel into the first partition on the card&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-debian-root-file-system&#34;&gt;2. Debian Root File System&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: running Debian system on the sdcard booting the ChromeOS kernel provided by archlinux and a debian filesystem.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the preparation of the debian rootfs, I inserted the sdcard in my laptop and mounted the partition which would host the rootfs. I used then debootstrap to install the base system.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;On the laptop&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Mount the second sdcard partition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir rootfs
sudo mount /dev/sdb2 rootfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use debootstrap in order to create a Debian sid root file system:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo debootstrap --arch=arm64 --verbose --foreign sid rootfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Changeroot to the new created filesystem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo chroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a user and set the user&amp;rsquo;s and the root passwords:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;passwd
adduser eramon
passwd eramon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install wicd-curses openssh-server sudo git xserver-xorg gnome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exit the chroot, umount the filesystem and sync:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;exit
umount rootfs
sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Back on the chromebook&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Insert the sdcard on the chromebook and press CTRL-U as soon as the boot screen appears.&lt;/p&gt;

&lt;p&gt;The firmware files and the modules will be missing on the system. Get them from the archlinux tarball:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo cp -r rootfs/lib/firmware /lib/
sudo cp -r rootfs/lib/modules/* /lib/modules/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module files in archlinux seem to be compressed: they have the extension .ko.gz. In order for them to work with the debian filesystem, I had to unzip them first.&lt;/p&gt;

&lt;h2 id=&#34;3-mainline-linux-kernel&#34;&gt;3. Mainline Linux Kernel&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: replace the ChromeOS kernel through the mainline linux kernel.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As a reference, I read the instructions for building a package on the archlinux PKGBUILD file for linux-gru in order to figure out which steps needed to be done:
&lt;a href=&#34;https://github.com/archlinuxarm/PKGBUILDs/blob/master/core/linux-gru/PKGBUILD&#34; target=&#34;_blank&#34;&gt;archlinuxarm/PKGBUILDS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In order to avoid cross compiling issues and to keep things simple, I aimed to do all the compiling and even the flashing directly on the chromebook. At this stage I had already a working environment consisting on the chromeos kernel and the new debian filesystem.&lt;/p&gt;

&lt;p&gt;First get the mainline kernel source code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git linux-git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get into the source directory and generate a default configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd linux-git
make defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile the kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make Image Dtbs Modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download the kernel.its file used by arch linux to build their package:
&lt;a href=&#34;https://github.com/archlinuxarm/PKGBUILDs/blob/master/core/linux-gru/kernel.its&#34; target=&#34;_blank&#34;&gt;kernel.its&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are several configurations in this file, we only need the first one. We also need to modify the path and name of the dtbs file.&lt;/p&gt;

&lt;p&gt;I modified the file as follows:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/chromebook/mainlinekernel.its&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook/mainlinekernel.its&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dts-v1/;

/ {
    description = &amp;quot;Linux mainline kernel image with one blob&amp;quot;;
    images {
        kernel@1{
            description = &amp;quot;kernel&amp;quot;;
            data = /incbin/(&amp;quot;linux-git/arch/arm64/boot/Image&amp;quot;);
            type = &amp;quot;kernel_noload&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            os = &amp;quot;linux&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            load = &amp;lt;0&amp;gt;;
            entry = &amp;lt;0&amp;gt;;
        };
        fdt@1{
            description = &amp;quot;rk3399-gru-bob.dtb&amp;quot;;
            data = /incbin/(&amp;quot;linux-git/arch/arm64/boot/dts/rockchip/rk3399-gru-bob.dtb&amp;quot;);
            type = &amp;quot;flat_dt&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            hash@1{
                algo = &amp;quot;sha1&amp;quot;;
            };
        };
    };
    configurations {
        default = &amp;quot;conf@1&amp;quot;;
        conf@1{
            kernel = &amp;quot;kernel@1&amp;quot;;
            fdt = &amp;quot;fdt@1&amp;quot;;
        };
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkimage -D &amp;quot;-I dts -O dtb -p 2048&amp;quot; -f mainlinekernel.its vmlinux.uimg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare the cmdline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;console=ttyS2,115200n8 earlyprintk=ttyS2,115200n8 console=tty1 init=/sbin/init root=PARTUUID=%U/PARTNROFF=1 rootwait rw noinitrd loglevel=4&amp;quot; &amp;gt; cmdline_mainline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate an empty bootloader.bin file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=bootloader.bin bs=512 count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run vbutil in order to generate a boot image for the chromebook:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vbutil_kernel
        --pack vmlinux.kpart
        --version 1
        --vmlinuz vmlinux.uimg
        --arch aarch64
        --keyblock /usr/share/vboot/devkeys/kernel.keyblock
        --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk
        --config cmdline_mainline
        --bootloader bootloader.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flash the new generated image to the first partition of the sdcard, sync and reboot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dd if=vmlinuz.kpart of=/dev/mmcblk1p1
sudo sync
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My script automating the aforementioned steps (mkimage, cmdline, vbutil) is available here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eramons/chromebook/blob/master/run.sh&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook/blob/master/run.sh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In case the screen remains blank when trying to boot the new kernel it helps to do serial port debugging with the help of a SuzyQable:
&lt;a href=&#34;https://www.chromium.org/chromium-os/ccd#TOC-SuzyQ-SuzyQable&#34; target=&#34;_blank&#34;&gt;SuzyQable&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use the USB-C port close to the screen, since the other one does not offer a serial port connection.&lt;/li&gt;
&lt;li&gt;Make sure the cable is plugged in the right position (the letters DBG have to be upside).&lt;/li&gt;
&lt;li&gt;Use minicom to connect via serial port and follow the boot process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-troubleshooting&#34;&gt;4. Troubleshooting&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: modify the kernel configuration as needed in order to have all hardware working. Install missing firmware.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After a first test run - compiling and flashing the kernel with the default configuration - I identified several flaws:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The wireless was not working&lt;/li&gt;
&lt;li&gt;The touchscreen was not working&lt;/li&gt;
&lt;li&gt;The touchpad was not working&lt;/li&gt;
&lt;li&gt;The sound was not working&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wireless&#34;&gt;Wireless&lt;/h3&gt;

&lt;p&gt;A look to dmesg revealed that the problem was just that the firmware files were missing.&lt;/p&gt;

&lt;p&gt;Comparing with the running ChromeOS system on the same chromebook, I found out which firmware files were missing and which debian package will provide them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install firmware-libertas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Notes:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;In order to install this firmware the contrib non-free sources must be included in /etc/apt/sources.list&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Before getting the wi-fi to work, I used an ethernet cable and an usb-to-ethernet adapter&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After installing the firmware package wireless networking worked perfectly.&lt;/p&gt;

&lt;h3 id=&#34;touchscreen-touchpad&#34;&gt;Touchscreen &amp;amp; Touchpad&lt;/h3&gt;

&lt;p&gt;In order for the touchscreen and the touchpad to work, we need to manually add the missing kernel modules to the kernel configuration and re-compile.&lt;/p&gt;

&lt;p&gt;Edit .config to include the following devices as kernel modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CONFIG_MOUSE_ELAN_I2C=m
CONFIG_MOUSE_ELAN_I2C_I2C=m
CONFIG_TOUCHSCREEN_ELAN=m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-build the kernel with make, make a new version with mkimage and generate a chromebook bootable image with vbutil_kernel, same as before.&lt;/p&gt;

&lt;p&gt;After this, we see the elan touchpad in /proc/bus/input/devices. The touchpad is working.&lt;/p&gt;

&lt;h3 id=&#34;sound&#34;&gt;Sound&lt;/h3&gt;

&lt;p&gt;The sound wasn&amp;rsquo;t working, although the corresponding modules seemed to be in place after comparing with a running ChromeOS system on the same device.&lt;/p&gt;

&lt;p&gt;In addition, the sound settings in gnome only showed a &amp;ldquo;dummy output&amp;rdquo; as sound device. Apparently Debian does not include users in the audio group by default, so adding the user to the group improved the situation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adduser eramon audio 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the sound wasn&amp;rsquo;t still working, I was able to see two proper output devices in the sound settings in gnome.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;At the time of this writing, the sound is still not working.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;further-issues&#34;&gt;Further issues&lt;/h3&gt;

&lt;p&gt;There is some other issues I did not go into:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The system seems to recover well from suspend when it suspends in its own (after no pressing any key for a while). However, if closing the lid manually, the system is not able to recover.&lt;/li&gt;
&lt;li&gt;The sound, brightness and other such keys (the top row on the Asus Chromebook keyboard) does not work as intended. Maybe just a configuration issue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-kernel-and-rootfs-on-the-chromebook-disk&#34;&gt;5. Kernel and rootfs on the chromebook disk&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: Instead of booting from the sdcard, boot from the chromebook internal ssd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we&amp;rsquo;ll need several tries in order for the custom built kernel to boot, it&amp;rsquo;s good to be able to boot both from the sdcard and from the internal drive. With Ctrl-D we&amp;rsquo;ll be able to boot the experimental kernel we are building and with Ctrl-U we&amp;rsquo;ll always be able to boot the already working mainline kernel on the sdcard first partition.&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use gparted to resize the stateful partition&lt;/li&gt;
&lt;li&gt;Create a new KERN-D and ROOT-D partitions and change the boot priorities&lt;/li&gt;
&lt;li&gt;Flash the kernel to the KERN-D partition&lt;/li&gt;
&lt;li&gt;Install a base debian system on ROOT-D using debootstrap&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Consequence: ChromeOS won&amp;rsquo;t boot anymore. The reason is that resizing a partition changes the boot priority of the KERN partitions on the same disk as the resized partition.&lt;/p&gt;

&lt;p&gt;If you plan to restore ChromeOS at some point, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cgpt show /dev/mmcblk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the output. In order to have ChromeOS to boot again, the values of this fields must be set as they were originally (using cgpt).
For example, the following command will restore the settings of KERN-A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cgpt add -i 2 -S 1 -T 0 -P 2 /dev/mmcblk1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that after doing this, it won&amp;rsquo;t be possible to boot debian anymore with Ctrl-D. Unfortunately coreboot/depthcharge only allow to boot one kernel (with Ctrl-D).&lt;/p&gt;

&lt;p&gt;Original settings (output of cgpt show):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;KERN-A: priority=2 tries=0 successful=1&lt;/li&gt;
&lt;li&gt;KERN-B: priority=1 tries=0 successful=1&lt;/li&gt;
&lt;li&gt;KERN-C: priority=0 tries=15 successful=0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So I resized the so called &amp;ldquo;stateful partition&amp;rdquo; from 10.53 GB to 5.00 GB:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     8671232    10485760       1  Label: &amp;quot;STATE&amp;quot;
                                  Type: Linux data
                                  UUID: 1F4D5818-8E6B-0746-B1F9-E2E206777C85
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I created two new partitions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For my debian kernel: KERN-D with size 100 MB&lt;/li&gt;
&lt;li&gt;For my debian rootfs: ROOT-D with size 9.45 GB (e.g. all unallocated space after resize STATE and creating KERN-D)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    30539776      204800      13  Label: &amp;quot;KERN-D&amp;quot;
                                  Type: ChromeOS kernel
                                  UUID: 9CAA153C-8A88-0A4D-B750-FA2F52FB3A2E
                                  Attr: priority=10 tries=5 successful=1 
    10719232    19820544      14  Label: &amp;quot;ROOT-D&amp;quot;
                                  Type: 0FC63DAF-8483-4772-8E79-3D69D8477DE4
                                  UUID: C5E4E377-6D8F-4747-AA1F-6A8EEDDF031A
                                  UUID: C5E4E377-6D8F-4747-AA1F-6A8EEDDF031A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set the priority, tries and succesful flag for the KERN-D partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cgpt add -i 1 -S 1 -T 0 -P 2 /dev/mmcblk0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use debootstrap to create a debian rootfs on the new ROOT-D:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/mmcblk1p14 dev/mnt
sudo debootstrap sid dev/mnt
sudo chroot dev/mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After chroot-ing to the new filesystem, I set the hostname, the root password, created an user and installed some useful packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;passwd
adduser eramon
cat &amp;quot;chupito&amp;quot; &amp;gt; /etc/hostname
apt-get install locales wicd-curses sudo
dpkg-reconfigure locales
visudo
exit
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test the new setup is working, I flashed the working mainline kernel to KERN-D. For that, I modified the cmdline in order to use ROOT-D as the rootfs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;quot;console=ttyS2,115200n8 earlyprintk=ttyS2,115200n8 console=tty0 init=/sbin/init root=PARTUUID=c5e4e377-6d8f-4747-aa1f-6a8eeddf031a rootwait rw noinitrd loglevel=4&amp;quot; &amp;gt; cmdline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE: the PARTUUID of the rootfs partition is hardcoded - it shouldn&amp;rsquo;t but I did not know how to do otherwise&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To find out the PARTUUID of ROOT-D:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l /dev/disk/by-partuuid/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run vbutil as before using this modified cmdline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vbutil_kernel 
	--pack vmlinux.kpart 
	--version 1 
	--vmlinuz vmlinux.uimg 
	--arch aarch64 
	--keyblock /usr/share/vboot/devkeys/kernel.keyblock 
	--signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk 
	--config cmdline 
	--bootloader bootloader.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flash the modified kernel image to the KERN-D partition and reboot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=vmlinux.kpart of=/dev/mmcblk1p13
sudo sync
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After doing this, I was able to boot my custom mainline kernel with Ctrl-D. Once logged in over serial, we can install the X system and other necessary packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install xserver-xorg gnome firmware-libertas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;NOTE I: same as before and before getting the wi-fi to work, I had to use a network cable.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE II: the chromebook has only a little drive (16 GB). For a productive setup, I ended up moving my /home partition to the sdcard - letting only the base system / on the ROOT-D partition.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-debian-kernel&#34;&gt;6. Debian Kernel&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Goal: replace the mainline linux kernel through the latest debian kernel.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get the latest kernel source&lt;/li&gt;
&lt;li&gt;Modify the kernel in order to include the modules for the touchpad and touchscreen to work&lt;/li&gt;
&lt;li&gt;Build the debian package and install it&lt;/li&gt;
&lt;li&gt;Modify the FDT image in order to include an initramfs since the debian kernel can&amp;rsquo;t boot without it&lt;/li&gt;
&lt;li&gt;Build the kernel image&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Instructions for re-building a debian kernel package (see &amp;ldquo;Building a custom kernel from Debian kernel source&amp;rdquo;):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kernel-team.pages.debian.net/kernel-handbook/ch-common-tasks.html#s-common-official&#34; target=&#34;_blank&#34;&gt;Rebuilding official Debian kernel packages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Get the kernel source code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install linux-source-4.19
tar xaf /usr/src/linux-source-4.19.16.tar.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install build-essential, fakeroot, build-dep, devscripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the following command in order to generate the default configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit .config in order to include the necessary kernel modules we found out in the &amp;ldquo;Troubleshooting&amp;rdquo; section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi .config

CONFIG_MOUSE_PS2_ELANTECH=m
CONFIG_MOUSE_ELAN_I2C=m
CONFIG_TOUCHSCREEN_ELAN=m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;TODO: In order for the device to be supported in the future, submit a bug to the debian kernel team in order to suggest including the missing modules.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Build the kernel package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make deb-pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install following file - generated by a succesfull build:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -i linux-image-4.19.16-1_arm64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install -among others- the following files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/boot/initrd-img-4.19.16
/boot/dtbs/rockchip/rk3399-gru-bob.dtb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chromebooks don&amp;rsquo;t use a ramdisk for booting. For the mainline kernel we used before, we didn&amp;rsquo;t use one either. However in order for Debian to boot, a initramfs (or ramdisk) is mandatory.&lt;/p&gt;

&lt;p&gt;Get the files we need for making the image and which will be referenced in kernel.its:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kernel: get the Image file from the compiled source: arch/arm64/boot/Image&lt;/li&gt;
&lt;li&gt;ramdisk: /boot/initrd-img-4.19.16 installed by dpkg before&lt;/li&gt;
&lt;li&gt;dtb: arch/arm64/boot/dts/rockchip/rk3399-gru-bob.dtb (also available under /boot/dtbs/rockchip/rk3399-gru-bob.dtb installed by dpkg before)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Edit the kernel.its file we used before in order to include a ramdisk:
&lt;a href=&#34;https://github.com/eramons/chromebook/blob/master/debkernel.its&#34; target=&#34;_blank&#34;&gt;https://github.com/eramons/chromebook/blob/master/debkernel.its&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dts-v1/;

/ {
    description = &amp;quot;Debian kernel image with one blob for the Asus C101 (Bob) and initramfs&amp;quot;;

    images {
        kernel@1{
            description = &amp;quot;kernel&amp;quot;;
            data = /incbin/(&amp;quot;linux/debian/arch/arm64/boot/Image&amp;quot;);
            type = &amp;quot;kernel_noload&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            os = &amp;quot;linux&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            load = &amp;lt;0&amp;gt;;
            entry = &amp;lt;0&amp;gt;;
        };
        fdt@1{
            description = &amp;quot;rk3399-gru-bob.dtb&amp;quot;;
            data = /incbin/(&amp;quot;linux/debian/arch/arm64/boot/dts/rockchip/rk3399-gru-bob.dtb&amp;quot;);
            type = &amp;quot;flat_dt&amp;quot;;
            arch = &amp;quot;arm64&amp;quot;;
            compression = &amp;quot;none&amp;quot;;
            hash@1{
                algo = &amp;quot;sha1&amp;quot;;
            };
        };
	ramdisk@1 {
           description = &amp;quot;initramfs&amp;quot;;
           data = /incbin/(&amp;quot;/boot/initrd.img-4.19.16&amp;quot;);
           type = &amp;quot;ramdisk&amp;quot;;
           arch = &amp;quot;arm64&amp;quot;;
           compression = &amp;quot;none&amp;quot;;
           hash@1 {
                algo = &amp;quot;sha1&amp;quot;;
           };
	};
    };
    configurations {
        default = &amp;quot;conf@1&amp;quot;;
        conf@1{
            kernel = &amp;quot;kernel@1&amp;quot;;
            fdt = &amp;quot;fdt@1&amp;quot;;
            ramdisk = &amp;quot;ramdisk@1&amp;quot;;
        };
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkimage -D &amp;quot;-I dts -O dtb -p 2048&amp;quot; -f debkernel.its vmlinux.uimg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find out the partition UID of the root partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l /dev/disk/by-partuuid/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare the cmdline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;console=ttyS2,115200n8 earlyprintk=ttyS2,115200n8 console=tty0 init=/sbin/init root=PARTUUID=c5e4e377-6d8f-4747-aa1f-6a8eeddf031a rootwait rw loglevel=4&amp;quot; &amp;gt; cmdline_debian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate an empty bootloader.bin file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=bootloader.bin bs=512 count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run vbutil in order to generate a boot image for the chromebook:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vbutil_kernel 
	--pack vmlinux.kpart 
	--version 1 
	--vmlinuz vmlinux.uimg 
	--arch aarch64 
	--keyblock /usr/share/vboot/devkeys/kernel.keyblock 
	--signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk 
	--config cmdline_debian 
	--bootloader bootloader.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flash the new generated image to the ROOT-D partition on the chromebook, sync and reboot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dd if=vmlinuz.kpart of=/dev/mmcblk1p14
sudo sync
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done :) Debian on the chromebook: a debian rootfs and a customized, self-built debian kernel.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And now? Next steps:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Coreboot/Depthcharge: build an u-boot payload for the Asus C101. Extend flash-kernel to support the board.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Alternatively, build a second depthcharge payload loaded through the legacy mechanism provided by the chromebooks (Ctrl-L) which loads the KERN-D kernel.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Debian on Radxa Rock Square</title>
      <link>https://eramons.github.io/techblog/post/rock2_debian/</link>
      <pubDate>Thu, 27 Jul 2017 15:03:58 +0200</pubDate>
      
      <guid>https://eramons.github.io/techblog/post/rock2_debian/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Radxa Rock 2 Square is a Rockchip RK3288 based solution.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.radxa.com/rock2/images/e&#34; target=&#34;_blank&#34;&gt;Available images&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The available images run with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A modified version of u-boot&lt;/li&gt;
&lt;li&gt;The Rabian operating system (which is based on Debian 8)&lt;/li&gt;
&lt;li&gt;A custom radxa kernel.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The goal is to get a pure Debian distribution up and running on the board:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Debian u-boot&lt;/li&gt;
&lt;li&gt;Debian armhf linux-image kernel&lt;/li&gt;
&lt;li&gt;Pure Debian root file system&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For this small project, we have two Radxa Rock 2 Square boards:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first one used for development, on which we aim to run Debian, booting the Radxa kernel with the Radxa u-boot. We&amp;rsquo;ll run using the internal flash storage of the board. This will be the &lt;em&gt;Development Board&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The second one used as testing platform. The goal is to be able to boot an official Debian kernel on this one using the official Debian u-boot and run an unmodified Debian sid on it. We&amp;rsquo;ll boot from a SD card. This will be the &lt;em&gt;Integration Board&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We also need a SD card with a capacity of 8 gigabytes at least.&lt;/p&gt;

&lt;h2 id=&#34;try-out-a-debian-based-distribution&#34;&gt;Try out a debian-based distribution&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Connect the board to a keyboard and a monitor or use the serial port of the board and minicom from your laptop to see the output of the board.&lt;/p&gt;

&lt;p&gt;First of all, we will try an existing image to see how it works. The image we are using is a Debian-based one which will be flashed to the board internal storage. Flashing an existing image to the board with the instructions and flash tool provided by Radxa is straightforward, just follow the instructions on the website:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.radxa.com/Rock/flash_the_image&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Flash the image&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In a nutshell:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Download the Image:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.radxa.com/rock2/images/rabian/emmc/rock2_square_rabian_150720_5d53487_emmc.img.xz&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Rabian SD Image&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Download and unzip the Radxa flashing tool:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.radxa.com/rock/tools/linux/Linux_Upgrade_Tool_v1.21.zip&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Radxa Flashing Tool&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Boot the board in bootloader mode and flash the image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo radxa/Linux_Upgrade_Tool_v1.21/upgrade_tool uf radxa/rock2_square_rabian_150720_5d53487_emmc.img
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A better alternative is to use the rkflashtool which is available as a Debian package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install rkflashtool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The board will reboot automatically after the image flash is completed. Attaching a HDMI monitor and a keyboard to the board you should be able to log in to the Rabian system. Both the username and the password are &amp;ldquo;rock2&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;create-debian-rootfs&#34;&gt;Create Debian rootfs&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;After having tried out Rabian on the Rock2, we aim to run a newer, unmodified version of Debian on the board. In order to go there, we need to replace the root filesystem through a self-built one.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use the Debian utility debootstrap for building the rootfs. The easiest and safest way is to use the available Rabian system - before replacing the rootfs - for setting up a custom rootfs with debootstrap.&lt;/p&gt;

&lt;p&gt;NOTE: it is also possible to generate the rootfs on other platform, using debootstrap &amp;ndash;first-stage on the host architecture and &amp;ndash;second-state using qemu. However, trying to do so lead to an EXT3 journal during the booting process. The reason is that the mkfs version used for creating the file system was much newer than the radxa kernel, which at the time of this writting was already quite old.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Boot the board and log in to the system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;username: rock2
password:
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create the file which will host the root file system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=debian.ext4 bs=1M count=4096
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create an ext4 filesystem on the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkfs.ext4 debian.ext4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The execution of the mkfs command is actually the reason for creating the rootfs file on the Rock2 directly. Creating the file system on another host which a newer kernel can lead to a journal error when trying to boot the system afterwards.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mount the file as a loop device:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount -o loop rootfs.ext4 /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use Debootstrap to download a Debian sid to the mount point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;debootstrap sid /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the kernel modules from the running Rabian system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /mnt/lib/modules
sudo cp -r /lib/modules/* /mnt/lib/modules

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change root to the new filesystem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chroot /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using sudo, allow root rights to the new created user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;visudo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add root mount point to fstab:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo echo &amp;quot;/dev/mmcblk0p2 / ext4 relatime,errors=remount-ro 0 1&amp;quot; &amp;gt; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do some fine tuning on the new filesystem.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Create a non-root user (and set his password):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adduser eramon
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install some packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install sudo, openssh-server, locales
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course further installation of packages can follow later after we finally boot the system.j&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modify /etc/network/interfaces in order for the new system to get connectivity automatically&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set the hostname:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo absinthe &amp;gt; /etc/hostname
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add the following line to  /etc/hosts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.0.1   absinthe
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The Debian filesystem is now ready. Umount the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo umount /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the file to your laptop or computer. We&amp;rsquo;ll use it twice afterwards:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Flash the filesystem on the development board&lt;/li&gt;
&lt;li&gt;Copy the rootfs to the second partition of the sdcard&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;flash-the-filesystem&#34;&gt;Flash the filesystem&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The default rootfs (Rabian) provided with the complete image we flashed at the beginning will be now replaced by our own Debian rootfs. In order to do that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Put the board into bootloader mode (same as you did before when flashing the complete image)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the radxa flashtool for flashing the rootfs into the correct place in the internal memory of the board:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo radxa/Linux_Upgrade_Tool_v1.21/upgrade_tool di linuxroot debian.ext4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reboot the board and log in with the credentials you set before.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;prepare-the-sd-card&#34;&gt;Prepare the SD Card&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;On your laptop&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;partitions&#34;&gt;Partitions&lt;/h3&gt;

&lt;p&gt;The SD card partition scheme must be as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One 1G partition for /boot&lt;/li&gt;
&lt;li&gt;One 5G partition for rootfs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Insert the SD card and check the device name using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dmesg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/partitions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In these examples we asume /dev/mmcblk1 to be the SD card.&lt;/p&gt;

&lt;p&gt;Use fdisk to create the partitions as explained above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After partitioning the SD, create an EXT2 filesystem on the boot partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs.ext2 /dev/sdb2
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rootfs-partition&#34;&gt;Rootfs Partition&lt;/h3&gt;

&lt;p&gt;Using dd, copy the rootfs partition created before to the sdcard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=rootfs.ext4 of=/dev/sdb2
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;boot-partition&#34;&gt;Boot Partition&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Development Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Insert the sdcard in the development board. Mount the first (boot) partition at /boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/mmcblk1p1 /boot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the generation of the boot files, we will use flash-kernel. flash-kernel is a script which will put the kernel and initramfs in the boot location of embedded devices that don&amp;rsquo;t load the kernel and initramfs directly from /boot.&lt;/p&gt;

&lt;p&gt;The Radxa Rock2 was not supported by flash-kernel. I submited a patch within a bug report:
&lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=868166&#34; target=&#34;_blank&#34;&gt;flash-kernel bug report&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since the linux kernel did support the board, fixing this was quite straightforward. The patch consisted on adding an entry for the Rock2 to /usr/share/flash-kernel/db/all/db:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Machine: Radxa Rock 2 Square
Kernel-Flavors: armmp armmp-lpae
DTB-Id: rk3288-rock2-square.dtb
Boot-Script-Path: /boot/boot.scr
U-Boot-Script-Name: bootscr.uboot-generic
Required-Packages: u-boot-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install flash-kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install flash-kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the debian kernel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-cache search linux-image
sudo apt-get install linux-image-4.11.0-2-armmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The installation of the kernel will copy the kernel image and the initramfs on /boot. In addition to this, the installation process will invoke flash-kernel which will install the boot script and the device tree binary on the same location:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eramon@absinthe:/boot$ ls
boot.scr               dtb-4.11.0-2-armmp         System.map-4.11.0-2-armmp
config-4.11.0-2-armmp  dtbs                       vmlinuz-4.11.0-2-armmp
dtb                    initrd.img-4.11.0-2-armmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Umount the sdcard partition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo umount /boot
sudo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debian-s-u-boot&#34;&gt;Debian&amp;rsquo;s U-Boot&lt;/h3&gt;

&lt;p&gt;Download Debian u-boot from GitHub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://anonscm.debian.org/git/collab-maint/u-boot.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configure and build:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make rock2_defconfig
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After succesfully building the source, two binaries were generated:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u-boot.bin&lt;/li&gt;
&lt;li&gt;spl/u-boot-spl.bin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Rockchip SoCs bootrom needs u-boot to be flashed to the SD card:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In a special format called IDB&lt;/li&gt;
&lt;li&gt;With offset 0x40 block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to generate the IDB image, use the mkimage tool provided by u-boot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tools/mkimage -n rk3288 -T rksd -d spl/u-boot-spl.bin rk3288_idb.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the rock2 board, the kernel setting CONFIG_ROCKCHIP_SPL_BACK_TO_BROM is by default set to 1. This means that the u-boot binary must be appended to the IDB image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat u-boot.bin &amp;gt;&amp;gt; rk3288_idb.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete image must be now flashed to offset 0x40 on the SD card (e.g. seek=64 as dd parameter):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=rk3288_idb.img of=/dev/mmcblk1 seek=64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this way worked, the right approach is to have a debian package supporting the board.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO u-boot patch for Rock2 support&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;boot-from-the-sd-card&#34;&gt;Boot from the SD Card&lt;/h2&gt;

&lt;p&gt;The sdcard is now ready. In a nutshell, we did the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Generating and installing all necessary boot files on the development board, with the first sdcard partition mounted on /boot&lt;/li&gt;
&lt;li&gt;Creating a debian file system and copying it to the second sdcard partition&lt;/li&gt;
&lt;li&gt;Building u-boot and copying the files to offset 0x40 on the sdcard.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Integration Board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The board is able to boot both from internal memory and from a SD card: if a SD card is inserted, it will check first there for a bootable system. However, this is not true for u-boot: even if the SD card is equiped with a running u-boot, the board will always boot from the u-boot stored on the internal memory. In order to solve this, allowing the rock2 to use the u-boot on the SD card, we need to &amp;ldquo;brick&amp;rdquo; the board, zeroing the memory position where u-boot is located.&lt;/p&gt;

&lt;p&gt;I found some useful information &lt;a href=&#34;http://git.denx.de/?p=u-boot.git;a=blob;f=doc/README.rockchip;h=e0572c80b9c7d6e22bfc695d0d73fde74f6789d5;hb=df61a74e6845ec9bdcdd48d2aff5e9c2c6debeaa&#34; target=&#34;_blank&#34;&gt;here.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The firefly board refered to this README has the same architecture as the Rock2. Among other things, on this README is described how to remove the existing u-boot from the board, thus allowing to boot from a custom u-boot on the SD card:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=/dev/mmcblk0 bs=1M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the location where u-boot is stored in the internal flash of the board is zeroised, the board won&amp;rsquo;t be able to boot from there anymore, trying to find a suitable u-boot on the sdcard.&lt;/p&gt;

&lt;p&gt;Connect your laptop to the serial port of the board and use minicom to see the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo minicom /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert the sdcard and reboot the integration board. Debian u-boot will boot the debian kernel and the debian system will start.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux buster/sid absinthe ttyS2

absinthe login: 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
